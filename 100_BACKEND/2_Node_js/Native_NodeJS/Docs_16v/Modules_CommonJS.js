// Modules: CommonJS modules

// В Node.js модульная система, каждый файл обрабатывается как отдельный модуль.
// Например, рассмотрим файл с именем foo.js:
const circle = require('./circle.js');
console.log(`The area of a circle of radius 4 is ${circle.area(4)}`);

// На первой строчке, foo.js загружает модуль circle.js который находится в том же каталоге,
// что и foo.js .
// Вот содержание circle.js:
const { PI } = Math;
exports.area = r => PI * r ** 2;
exports.circumference = r => 2 * PI * r;

/*
Модуль circle.js экспортировал функции area() и circumference(). 
Функции и объекты добавляются в корневой каталог модуля путем указания 
дополнительных свойств в специальном объекте экспорта.

Переменные, локальные для модуля, будут закрытыми, поскольку модуль заключен в 
функцию с помощью Node.js (см. оболочку модуля). В этом примере переменная PI 
является частной для circle.js .

Свойству module.exports может быть присвоено новое значение (например, функция или объект).
Ниже, bar.js использует модуль square, который экспортирует класс Square:
*/
const Square = require('./square.js');
const mySquare = new Square(2);
console.log(`The area of mySquare is ${mySquare.area()}`);

// Квадратный модуль определяется в square.js:
// Назначение экспорту не изменит модуль, необходимо использовать module.exports
module.exports = class Square {
  constructor(width) {
    this.width = width;
  }

  area() {
    return this.width ** 2;
  }
};
// Модульная система реализована в модуле require("модуль").

// Доступ к основному модулю
/*
Когда файл запускается непосредственно из Node.js , require.main устанавливается в свой модуль. 
Это означает, что можно определить, был ли файл запущен напрямую, протестировав модуль 
require.main ===.
Для файла foo.js , это будет верно, если запускать через узел foo.js , но ложно, 
если выполняется с помощью require('./foo').
Поскольку модуль предоставляет свойство filename (обычно эквивалентное __filename), 
точку входа текущего приложения можно получить, проверив require.main.filename.
*/

// Советы менеджера пакетов
/*
Семантика этого Node.js функция require() была разработана таким образом, чтобы быть достаточно 
общей для поддержки разумных структур каталогов. Программы диспетчера пакетов, такие как dpkg, 
rpm и npm, надеюсь, найдут возможным создавать собственные пакеты из Node.js модули без изменений.
Ниже мы приводим предлагаемую структуру каталогов, которая могла бы работать:
Допустим, мы хотели, чтобы в папке /usr/lib/node/<некоторый пакет>/<некоторая версия> 
содержалось содержимое определенной версии пакета.
Пакеты могут зависеть друг от друга. Для установки пакета foo может потребоваться 
установить определенную версию package bar. Пакет bar сам по себе может иметь зависимости, 
и в некоторых случаях они могут даже сталкиваться или образовывать циклические зависимости.
Потому что Node.js просматривает реальный путь любых загружаемых модулей (то есть разрешает 
символические ссылки), а затем ищет их зависимости в папках node_modules, эта ситуация может 
быть решена с помощью следующей архитектуры:
/usr/lib/узел/foo/1.2.3/: Содержимое пакета foo версии 1.2.3.
/usr/lib/узел/панель/4.3.2/: Содержимое пакета панели, от которого зависит foo.
/usr/библиотека/узел/foo/1.2.3/node_modules/панель: Символическая ссылка на 
/usr/библиотека/узел/панель/4.3.2/.
/usr/lib/узел/bar/4.3.2/node_modules/*: Символические ссылки на пакеты, от которых зависит bar.
Таким образом, даже если возникнет цикл или возникнут конфликты зависимостей, каждый модуль 
сможет получить версию своей зависимости, которую он может использовать.
Когда код в пакете foo действительно требует ('bar'), он получит версию с символической 
ссылкой в /usr/lib/node/foo/1.2.3/node_modules/bar. Затем, когда код в пакете bar вызывает 
require('quux'), он получит версию с символической ссылкой в 
/usr/lib/node/bar/4.3.2/node_modules/quux.
Кроме того, чтобы сделать процесс поиска модулей еще более оптимальным, вместо того, 
чтобы помещать пакеты непосредственно в /usr/lib/узел, мы могли бы поместить их в 
/usr/lib/node_modules/<имя>/<версия>. Затем Node.js не буду утруждать себя поиском 
отсутствующих зависимостей в /usr/node_modules или /node_modules.
Для того, чтобы сделать модули доступными для Node.js ПОВТОРЯЮ, может быть полезно также 
добавить папку /usr/lib/node_modules в переменную среды $NODE_PATH. Поскольку поиск 
модулей с использованием папок node_modules является относительным и основан на реальном 
пути к файлам, вызывающим require(), сами пакеты могут находиться где угодно.
*/

// Расширение .mjs
/*
Невозможно делать require() для файлоы с расширением .mjs. Попытка сделать это приведет к ошибке. 
Расширение .mjs зарезервировано для модулей ECMAScript, которые не могут быть загружены с 
помощью require(). Дополнительные сведения см. в разделе Модули ECMAScript.
*/

// Все вместе...
/*
Чтобы получить точное имя файла, которое будет загружено при вызове require(), используйте 
функцию require.resolve().
Собрав воедино все вышесказанное, вот высокоуровневый алгоритм в псевдокоде того, 
что делает require():

require(X) из модуля по пути Y
1. Если X является основным модулем,
a. вернёт основной модуль
b. СТОП
2. Если X начинается с '/'
   a. установите Y в качестве корня файловой системы
3. Если X начинается с './' или '/' или '../'
ФАЙЛ. LOAD_AS_FILE(Y + X)
   b. КАТАЛОГ LOAD_AS_DIRECTORY(Y + X)
   c. ВЫБРОСИТЬ "не найдено"
4. Если X начинается с '#'
   a. LOAD_PACKAGE_IMPORTS(X, имя файла(Y))
5. LOAD_PACKAGE_SELF(X, имя файла(Y))
6. LOAD_NODE_МОДУЛИ(X, имя файла(Y))
7. ВЫБРОСИТЬ "не найдено"

ФАЙЛ LOAD_AS_FILE(X)
1. Если X является файлом, загрузите X в качестве формата расширения файла. остановка
2. Если X.js является файлом, загрузите X.js в виде текста JavaScript. остановка
3. Если X.json является файлом, преобразуйте X.json в объект JavaScript. остановка
4. Если X.узел является файлом, загрузите X.узел как двоичный аддон. остановка

LOAD_ИНДЕКС(X)
1. Если X/index.js это файл, загружающий X/index.js как текст на JavaScript. остановка
2. Если X/index.json является файлом, проанализируйте X/index.json в объект JavaScript. остановка
3. Если X/index.node является файлом, загрузите X/index.node в качестве двоичного дополнения. остановка

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. If "main" is a falsy value, GOTO 2.
   c. let M = X + (json main field)
   d. LOAD_AS_FILE(M)
   e. LOAD_INDEX(M)
   f. LOAD_INDEX(X) DEPRECATED
   g. THROW "not found"
2. LOAD_INDEX(X)

LOAD_NODE_MODULES(X, START)
1. let DIRS = NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_PACKAGE_EXPORTS(X, DIR)
   b. LOAD_AS_FILE(DIR/X)
   c. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = [GLOBAL_FOLDERS]
4. while I >= 0,
   a. if PARTS[I] = "node_modules" CONTINUE
   b. DIR = path join(PARTS[0 .. I] + "node_modules")
   c. DIRS = DIRS + DIR
   d. let I = I - 1
5. return DIRS

LOAD_PACKAGE_IMPORTS(X, DIR)
1. Find the closest package scope SCOPE to DIR.
2. If no scope was found, return.
3. If the SCOPE/package.json "imports" is null or undefined, return.
4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),
  ["node", "require"]) defined in the ESM resolver.
5. RESOLVE_ESM_MATCH(MATCH).

LOAD_PACKAGE_EXPORTS(X, DIR)
1. Try to interpret X as a combination of NAME and SUBPATH where the name
   may have a @scope/ prefix and the subpath begins with a slash (`/`).
2. If X does not match this pattern or DIR/NAME/package.json is not a file,
   return.
3. Parse DIR/NAME/package.json, and look for "exports" field.
4. If "exports" is null or undefined, return.
5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), "." + SUBPATH,
   `package.json` "exports", ["node", "require"]) defined in the ESM resolver.
6. RESOLVE_ESM_MATCH(MATCH)

LOAD_PACKAGE_SELF(X, DIR)
1. Find the closest package scope SCOPE to DIR.
2. If no scope was found, return.
3. If the SCOPE/package.json "exports" is null or undefined, return.
4. If the SCOPE/package.json "name" is not the first segment of X, return.
5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),
   "." + X.slice("name".length), `package.json` "exports", ["node", "require"])
   defined in the ESM resolver.
6. RESOLVE_ESM_MATCH(MATCH)

RESOLVE_ESM_MATCH(MATCH)
1. let { RESOLVED, EXACT } = MATCH
2. let RESOLVED_PATH = fileURLToPath(RESOLVED)
3. If EXACT is true,
   a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension
      format. STOP
4. Otherwise, if EXACT is false,
   a. LOAD_AS_FILE(RESOLVED_PATH)
   b. LOAD_AS_DIRECTORY(RESOLVED_PATH)
5. THROW "not found"
*/

/*
Кэширование#
Модули кэшируются после их первой загрузки. Это означает (среди прочего), что при 
каждом вызове require('foo') будет возвращен точно такой же объект, если он будет 
разрешен в том же файле.

При условии, что require.cache не изменен, многократные вызовы require('foo') не 
приведут к многократному выполнению кода модуля. Это важная особенность. С его помощью 
могут быть возвращены объекты "частично выполненные", что позволяет загружать переходные 
зависимости, даже если они вызывают циклы.

Чтобы модуль выполнял код несколько раз, экспортируйте функцию и вызывайте эту функцию.

Предостережения в отношении кэширования модулей#
Модули кэшируются на основе их разрешенного имени файла. Поскольку модули могут 
разрешаться с другим именем файла в зависимости от местоположения вызывающего модуля 
(загрузка из папок node_modules), это не гарантирует, что require('foo') всегда будет 
возвращать один и тот же объект, если он будет разрешен в разные файлы.

Кроме того, в файловых системах или операционных системах без учета регистра разные 
разрешенные имена файлов могут указывать на один и тот же файл, но кэш все равно будет 
рассматривать их как разные модули и будет перезагружать файл несколько раз. Например, 
require('./foo') и require('./FOO') возвращают два разных объекта, независимо от того, 
являются ли ./foo и ./FOO одним и тем же файлом или нет.

Основные модули#
История
Node.js имеет несколько модулей, скомпилированных в двоичный файл. Эти модули более 
подробно описаны в других разделах данной документации.

Основные модули определены в рамках Node.js источник и находятся в папке lib/.

Основные модули всегда предпочтительно загружаются, если их идентификатор передается 
в require(). Например, require('http') всегда будет возвращать встроенный HTTP-модуль, 
даже если существует файл с таким именем.

Основные модули также могут быть идентифицированы с помощью префикса node:, и в этом 
случае он обходит кэш require. Например, require('узел:http') всегда будет возвращать 
встроенный HTTP-модуль, даже если есть запись require.cache с этим именем.

Циклы#
При циклических вызовах require() модуль может не завершиться при его возврате.

Рассмотрим эту ситуацию:
*/
// a.js:
console.log('a starting');
exports.done = false;
const b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');

// b.js:
console.log('b starting');
exports.done = false;
const a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');

// main.js:
console.log('main starting');
const a = require('./a.js');
const b = require('./b.js');
console.log('in main, a.done = %j, b.done = %j', a.done, b.done);

/*
Когда main.js загружает файл a.js, тогда файл a.js, в свою очередь, загружает файл b.js. 
В этот момент b.js пытается загрузить файл a.js. Чтобы предотвратить бесконечный цикл, 
незавершенная копия объекта экспорта a.js возвращается в модуль b.js. Затем загрузка 
b.js завершается, и его объект экспорта предоставляется модулю a.js.

К тому времени main.js загрузил оба модуля, они оба закончены. Таким образом, 
результатом этой программы будет:

$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done = true, b.done = true

Требуется тщательное планирование, чтобы циклические зависимости модулей могли корректно работать в
приложении.

Файловые модули#
Если точное имя файла не найдено, то Node.js попытается загрузить
требуемое имя файла с добавленными расширениями: .js, .json и, наконец, .node.

Файлы .js интерпретируются как текстовые файлы JavaScript, а файлы .json анализируются
как текстовые файлы JSON. файлы .node интерпретируются как скомпилированные модули дополнений, 
загруженные с помощью process.dlopen().

Обязательный модуль с префиксом '/' является абсолютным путем к файлу. Например, 
require('/home/marco/foo.js ') загрузит файл по адресу /home/marco/foo.js .

Требуемый модуль с префиксом './' относится к файлу, вызывающему require(). То
есть, circle.js должен находиться в том же каталоге, что и foo.js для require('./circle'), 
чтобы найти его.

Без начальных символов "/", "./" или "../" для обозначения файла модуль должен быть либо
основным модулем, либо загружаться из папки node_modules.

Если указанный путь не существует, require() выдаст ошибку со свойством кода, 
установленным в 'MODULE_NOT_FOUND'.

Папки как модули#
Удобно организовывать программы и библиотеки в автономные каталоги, а затем предоставлять 
единую точку входа в эти каталоги. Существует три способа передачи папки в require() 
в качестве аргумента.

Первый - создать файл package.json в корне папки, в котором указан основной модуль. 
Пример файла package.json может выглядеть следующим образом:

{ "name" : "some-library",
  "main" : "./lib/some-library.js" }

Если бы это было в папке ./some-library, то require('./some-библиотека') 
попытался бы загрузить ./some-library/lib/some-library.js .

Это степень осведомленности о файлах package.json внутри Node.js .

Если в каталоге отсутствует файл package.json, или если запись "main" отсутствует 
или не может быть разрешена, то Node.js попытается загрузить index.js или файл 
index.node из этого каталога. Например, если в предыдущем примере не было файла 
package.json, то require('./some-библиотека') попытается загрузить:

./some-library/index.js
./некоторая библиотека/index.node
Если эти попытки провалятся, то Node.js сообщит об отсутствии всего модуля 
с ошибкой по умолчанию:

Error: Cannot find module 'some-library'

Загрузка из папок node_modules#
Если идентификатор модуля, переданный require(), не является основным модулем и 
не начинается с '/', '../' или './', то Node.js запускается в родительском каталоге 
текущего модуля, добавляет /node_modules и пытается загрузить модуль из этого 
местоположения. Node.js не будет добавлять node_modules к пути, который уже 
заканчивается на node_modules.

Если он там не найден, то перемещается в родительский каталог и так далее, пока 
не будет достигнут корень файловой системы.

Например, если файл в '/home/ry/projects/foo.js ' называется требовать('bar.js '), 
затем Node.js будет выглядеть в следующих местах, в таком порядке:

/home/ry/projects/node_modules/bar.js
/home/ry/node_modules/bar.js
/home/node_modules/bar.js
/node_modules/bar.js
Это позволяет программам локализовать свои зависимости, чтобы они не конфликтовали.

Можно потребовать, чтобы определенные файлы или подмодули распространялись вместе 
с модулем, включив суффикс пути после имени модуля. Например, требование 
("пример-модуль/путь/к/файлу") разрешит путь /к/файлу относительно того, 
где расположен пример-модуль. Путь с суффиксом соответствует той же семантике разрешения модуля.

Загрузка из глобальных папок#
Если переменной окружения NODE_PATH присвоено значение списка абсолютных путей, 
разделенных двоеточием, то Node.js будет искать эти пути для модулей, если они 
не найдены в другом месте.

В Windows ПУТЬ к узлу разделяется точкой с запятой (;) вместо двоеточий.

NODE_PATH изначально был создан для поддержки загрузки модулей с разных путей до того, 
как был определен текущий алгоритм разрешения модулей.

NODE_PATH по-прежнему поддерживается, но теперь он менее необходим, поскольку Node.js 
экосистема определилась с соглашением о размещении зависимых модулей. Иногда 
развертывания, которые полагаются на NODE_PATH, демонстрируют удивительное поведение, 
когда люди не знают, что NODE_PATH должен быть установлен. Иногда зависимости 
модуля изменяются, в результате чего при поиске пути к узлу загружается другая версия 
(или даже другой модуль).

Кроме того, Node.js будет выполнен поиск в следующем списке глобальных папок:

1: $ГЛАВНАЯ СТРАНИЦА/.node_modules
2: $ГЛАВНАЯ СТРАНИЦА/.node_libraries
3: $ПРЕФИКС/библиотека/узел
Где $HOME - это домашний каталог пользователя, а $ПРЕФИКС - это Node.js настроенный node_prefix.

Это в основном по историческим причинам.

Настоятельно рекомендуется размещать зависимости в локальной папке node_modules. 
Они будут загружаться быстрее и надежнее.

Оболочка модуля#
Перед выполнением кода модуля, Node.js обернет его оболочкой функции, 
которая выглядит следующим образом:
*/
(function (exports, require, module, __filename, __dirname) {
  // Module code actually lives in here
});
/*
Делая это, Node.js достигает нескольких целей:

Он сохраняет переменные верхнего уровня (определенные с помощью var, const или let), 
привязанные к модулю, а не к глобальному объекту.
Это помогает предоставить некоторые глобальные переменные, которые на самом деле 
специфичны для модуля, такие как:
Модуль и экспортирует объекты, которые разработчик может использовать для экспорта 
значений из модуля.
Удобные переменные __имя файла и __имя файла, содержащие абсолютное имя файла модуля 
и путь к каталогу.

Область применения модуля#

Имя каталога текущего модуля. Это то же самое, что и путь.dirname() __имени файла.

Пример: запущенный узел example.js от /Пользователей/mjr

*/
console.log(__dirname);
// Prints: /Users/mjr
console.log(path.dirname(__filename));
// Prints: /Users/mjr

/*
__filename
Имя файла текущего модуля. Это абсолютный путь к текущему файлу модуля с 
разрешенными символическими ссылками.

Для основной программы это не обязательно совпадает с именем файла, 
используемым в командной строке.

Имя каталога текущего модуля см. в разделе __имя_дира.

Примеры:

Запущенный узел example.js от /Пользователей/mjr

console.log(__filename);
// Prints: /Users/mjr/example.js
console.log(__dirname);
// Prints: /Users/mjr

Даны два модуля: a и b, где b - зависимость от a и существует структура каталогов:

/Users/mjr/app/a.js
/Users/mjr/app/node_modules/b/b.js
Ссылки на __имя файла в b.js вернут /Users/mjr/app/node_modules/b/b.js в то 
время как ссылки на __имя файла в файле.js вернут /Users/mjr/app/a.js .

exports

Ссылка на модуль.экспорт, который короче для ввода. Смотрите раздел о ярлыке экспорта 
для получения подробной информации о том, когда использовать экспорт и когда 
использовать module.exports.

module

Ссылку на текущий модуль см. в разделе об объекте модуля. В частности, 
module.exports используется для определения того, что модуль экспортирует и 
делает доступным через require().

require(id)

идентификатор <строка> имя модуля или путь
Возвращает: <любое> содержимое экспортированного модуля
Используется для импорта модулей, JSON и локальных файлов. Модули могут быть 
импортированы из node_modules. Локальные модули и файлы JSON могут быть 
импортированы с использованием относительного пути 
(например, ./, ./foo, ./bar/baz, ../foo), который будет разрешен для каталога 
с именем __dirname (если определено) или текущего рабочего каталога. 
Относительные пути в стиле POSIX разрешаются независимо от операционной 
системы, что означает, что приведенные выше примеры будут работать в Windows 
так же, как и в системах Unix.
*/
// Importing a local module with a path relative to the `__dirname` or current
// working directory. (On Windows, this would resolve to .\path\myLocalModule.)
const myLocalModule = require('./path/myLocalModule');

// Importing a JSON file:
const jsonData = require('./path/filename.json');

// Importing a module from node_modules or Node.js built-in module:
const crypto = require('crypto');
/*
require.cache

Модули кэшируются в этом объекте, когда они требуются. Удалив значение ключа 
из этого объекта, следующее требование перезагрузит модуль. Это не относится 
к встроенным аддонам, перезагрузка которых приведет к ошибке.

Также возможно добавление или замена записей. Этот кэш проверяется перед собственными 
модулями, и если в кэш добавляется имя, соответствующее собственному модулю, только 
вызовы node:-с префиксом require будут получать собственный модуль. Используйте с осторожностью!
*/
const assert = require('assert');
const realFs = require('fs');

const fakeFs = {};
require.cache.fs = { exports: fakeFs };

assert.strictEqual(require('fs'), fakeFs);
assert.strictEqual(require('node:fs'), realFs);
/*
require.extensions

Проинструктируйте require о том, как обращаться с определенными расширениями файлов.

Обрабатывайте файлы с расширением .js как .js:
*/
require.extensions['.sjs'] = require.extensions['.js'];
/*
Deprecated. В прошлом этот список использовался для загрузки модулей, отличных 
от JavaScript, в Node.js путем компиляции их по требованию. Однако на практике 
существуют гораздо лучшие способы сделать это, такие как загрузка модулей с 
помощью некоторых других Node.js программировать или заранее компилировать их в JavaScript.

Избегайте использования require.extensions. Использование может привести к 
незначительным ошибкам, а разрешение расширений замедляется с каждым зарегистрированным расширением.

require.main

Объект модуля, представляющий сценарий ввода, загруженный при Node.js процесс запущен. 
См. раздел "Доступ к основному модулю".

В entry.js сценарий:

console.log(require.main);
node entry.js
Module {
  id: '.',
  path: '/absolute/path/to',
  exports: {},
  filename: '/absolute/path/to/entry.js',
  loaded: false,
  children: [],
  paths:
   [ '/absolute/path/to/node_modules',
     '/absolute/path/node_modules',
     '/absolute/node_modules',
     '/node_modules' ] }
*/

/*
require.resolve(request[, options])

запросите <строку> Путь к модулю для разрешения.
параметры <Объект>
пути <строка[]> Пути для определения местоположения модуля. Если они присутствуют, 
эти пути используются вместо путей разрешения по умолчанию, за исключением 
глобальных папок, таких как $HOME/.node_modules, которые всегда включены. 
Каждый из этих путей используется в качестве отправной точки для алгоритма 
разрешения модулей, что означает, что иерархия node_modules проверяется из этого местоположения.
Возвращает: <строка>
Используйте внутренний механизм require() для поиска местоположения модуля, 
но вместо загрузки модуля просто верните разрешенное имя файла.

Если модуль не может быть найден, выдается ошибка MODULE_NOT_FOUND.

require.resolve.paths(request)

запрос <строка> Путь к модулю, пути поиска которого извлекаются.
Возвращает: <строка[]> | <null>
Возвращает массив, содержащий пути, которые были найдены во время разрешения запроса, 
или null, если строка запроса ссылается на основной модуль, например http или fs.

The module object

В каждом модуле свободная переменная модуля является ссылкой на объект, 
представляющий текущий модуль. Для удобства модуль.экспорт также доступен через 
модуль экспорта-глобальный. модуль на самом деле не является глобальным, 
а скорее локальным для каждого модуля.

module.children

Объекты модуля, необходимые для этого в первый раз.

module.exports

Объект module.exports создается системой модулей. Иногда это неприемлемо; 
многие хотят, чтобы их модуль был экземпляром какого-либо класса. Для этого 
назначьте нужный объект экспорта в module.exports. Назначение нужного объекта 
экспорту просто приведет к повторной привязке локальной переменной экспорта, 
что, вероятно, не является желательным.

Например, предположим, что мы создавали модуль под названием a.js:
*/
const EventEmitter = require('events');

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(() => {
  module.exports.emit('ready');
}, 1000);
// Затем в другом файле мы могли бы сделать:
const a = require('./a');
a.on('ready', () => {
  console.log('module "a" is ready');
});
// Назначение модулю.экспорт должно быть выполнено немедленно. Это невозможно
// сделать ни в каких обратных вызовах. Это не работает:
// x.js:
setTimeout(() => {
  module.exports = { a: 'hello' };
}, 0);

// y.js:
const x = require('./x');
console.log(x.a);
/*
Переменная exports доступна в области действия модуля на уровне файла, и ей 
присваивается значение module.exports до оценки модуля.

Это позволяет использовать ярлык, так что module.exports.f = ... может быть 
записано более кратко как exports.f = .... Однако имейте в виду, что, как и 
любая переменная, если экспорту присваивается новое значение, оно больше не 
привязано к module.exports:
*/
module.exports.hello = true; // Exported from require of module
exports = { hello: false }; // Not exported, only available in the module
/*
Когда свойство module.exports полностью заменяется новым объектом, обычно 
также переназначается экспорт:
*/
module.exports = exports = function Constructor() {
  // ... etc.
};
/*
Чтобы проиллюстрировать поведение, представьте себе эту гипотетическую 
реализацию require(), которая очень похожа на то, что на самом деле выполняется require():
*/
function require(/* ... */) {
  const module = { exports: {} };
  ((module, exports) => {
    // Module code here. In this example, define a function.
    function someFunc() {}
    exports = someFunc;
    // At this point, exports is no longer a shortcut to module.exports, and
    // this module will still export an empty default object.
    module.exports = someFunc;
    // At this point, the module will now export someFunc, instead of the
    // default object.
  })(module, module.exports);
  return module.exports;
}

/*
module.filename

Полностью разрешенное имя файла модуля.

module.id

Идентификатор модуля. Обычно это полностью разрешенное имя файла.

module.isPreloading

Тип: <логическое значение> true, если модуль запущен во время Node.js фаза предварительной нагрузки.

module.loaded

Независимо от того, закончена загрузка модуля или он находится в процессе загрузки.

module.parent

Модуль, который первым потребовал этого, или нулевой, если текущий модуль является 
точкой входа текущего процесса, или неопределенный, если модуль был загружен 
чем-то, что не является модулем CommonJS (например, REPL или импорт).

module.path#
Имя каталога модуля. Обычно это то же самое, что и path.dirname() для module.id .

module.paths#
Пути поиска для модуля.

module.require(id)#
Возвращает: <любое> содержимое экспортированного модуля
Метод module.require() предоставляет способ загрузки модуля, как если бы require() 
был вызван из исходного модуля.

Для того чтобы это сделать, необходимо получить ссылку на объект модуля. Поскольку 
require() возвращает module.exports, а модуль обычно доступен только в коде 
определенного модуля, он должен быть явно экспортирован для использования.

Объект модуля#
Этот раздел был перенесен в раздел Modules: module API.

Поддержка Source map v3#
Этот раздел был перенесен в раздел Modules: module API.
*/
