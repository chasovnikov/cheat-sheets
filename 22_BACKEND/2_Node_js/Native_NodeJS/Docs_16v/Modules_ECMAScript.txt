Модули ECMAScript являются официальным стандартным форматом для упаковки кода 
JavaScript для повторного использования. Модули определяются с помощью различных 
инструкций импорта и экспорта.

Следующий пример модуля ES экспортирует функцию:

// addTwo.mjs
function addTwo(num) {
  return num + 2;
}

export { addTwo };

Следующий пример модуля ES импортирует функцию из файла add Two.mjs:

// app.mjs
import { addTwo } from './addTwo.mjs';

// Prints: 6
console.log(addTwo(4));

Node.js полностью поддерживает модули ECMAScript в том виде, в каком они указаны в настоящее 
время, и обеспечивает совместимость между ними и исходным форматом модуля CommonJS.


Позволяющий#
Node.js по умолчанию код JavaScript обрабатывается как модули CommonJS. Авторы могут 
рассказать Node.js для обработки кода JavaScript как модулей ECMAScript используйте 
расширение файла .mjs, поле "тип" пакета.json или флаг --input-type. Более подробную 
информацию см. в разделе Модули: Пакеты.


Пакеты#
Этот раздел был перенесен в раздел Модули: Пакеты.

спецификаторы импорта#
Терминология#
Спецификатором инструкции импорта является строка после ключевого слова from, например 
'путь' в import { sep } из 'пути'. Спецификаторы также используются в операторах экспорта 
из и в качестве аргумента выражения import().

Существует три типа спецификаторов:

Относительные спецификаторы, такие как './startup.js " или "../config.mjs". Они ссылаются 
на путь относительно местоположения импортируемого файла. Для этого всегда необходимо 
расширение файла.

Голые спецификаторы, такие как "какой-то пакет" или "какой-то пакет / перемешивание". 
Они могут ссылаться на основную точку входа пакета по имени пакета или на конкретный 
функциональный модуль в пакете с префиксом имени пакета в соответствии с примерами 
соответственно. Указание расширения файла необходимо только для пакетов без поля "экспорт".

Абсолютные спецификаторы, такие как 'file:///opt/nodejs/config.js '. Они прямо и 
недвусмысленно ссылаются на полный путь.

Разрешения голых спецификаторов обрабатываются Node.js алгоритм разрешения модуля. 
Все остальные разрешения спецификаторов всегда разрешаются только с помощью стандартной 
семантики относительного разрешения URL.

Как и в CommonJS, доступ к файлам модулей в пакетах можно получить, добавив путь к 
имени пакета, если только файл package.json пакета не содержит поля "экспорт", и в 
этом случае доступ к файлам в пакетах возможен только по путям, определенным в разделе "экспорт".

Для получения подробной информации об этих правилах разрешения пакетов, применимых к 
пустым спецификаторам, в Node.js разрешение модуля см. в документации по пакетам.

Обязательные расширения файлов#
При использовании ключевого слова import для разрешения относительных или абсолютных 
спецификаторов необходимо указать расширение файла. Индексы каталогов 
(например, './startup/index.js ') также должно быть полностью указано.

Это поведение соответствует тому, как импорт ведет себя в средах браузера, предполагая, 
что сервер обычно настроен.
URL-адреса#
Модули ES разрешаются и кэшируются в виде URL-адресов. Это означает, что файлы, 
содержащие специальные символы, такие как # и ? нужно сбежать.

поддерживаются схемы URL-адресов файл:, узел: и данные:. Спецификатор, такой как 
'https://example.com/app.js ' изначально не поддерживается в Node.js если только 
не использовать пользовательский загрузчик HTTPS.

файл: URL-адреса#
Модули загружаются несколько раз, если спецификатор импорта, используемый для их 
разрешения, содержит другой запрос или фрагмент.

import './foo.mjs?query=1'; // loads ./foo.mjs with query of "?query=1"
import './foo.mjs?query=2'; // loads ./foo.mjs with query of "?query=2"

На корневой каталог тома можно ссылаться через /, // или файл:///. 
Учитывая различия между разрешением URL и пути (например, сведения о процентной кодировке), 
рекомендуется использовать url.pathToFileURL при импорте пути.

данные: Импорт#
Добавлено в: v12.10.0
данные: URL-адреса поддерживаются для импорта со следующими типами MIME:

текст/javascript для
приложения модулей ES/json для
приложения JSON/was для Wasm
данные: URL-адреса разрешают только пустые спецификаторы для встроенных модулей и 
абсолютные спецификаторы. Разрешение относительных спецификаторов не работает, 
потому что данные: не является специальной схемой. Например, попытка загрузить 
./foo из data:текст/javascript, импортировать "./foo"; не удается разрешить, поскольку 
для данных: URL-адресов отсутствует понятие относительного разрешения. 
Примером используемых URL-адресов data: является:

import 'data:text/javascript,console.log("hello!");';
import _ from 'data:application/json,"world!"';

узел: Импорт#

Узел истории: URL-адреса поддерживаются в качестве альтернативного средства 
загрузки Node.js встроенные модули. Эта схема URL-адресов позволяет ссылаться на 
встроенные модули с помощью допустимых абсолютных строк URL-адресов.

import fs from 'node:fs/promises';

Встроенные модули#
Основные модули предоставляют именованный экспорт своего общедоступного API. 
Также предоставляется экспорт по умолчанию, который является значением экспорта CommonJS. 
Экспорт по умолчанию можно использовать, среди прочего, для изменения именованных экспортов. 
Именованный экспорт встроенных модулей обновляется только при вызове module.syncBuiltinESMExports().

import EventEmitter from 'events';
const e = new EventEmitter();
import { readFile } from 'fs';
readFile('./foo.txt', (err, source) => {
  if (err) {
    console.error(err);
  } else {
    console.log(source);
  }
});
import fs, { readFileSync } from 'fs';
import { syncBuiltinESMExports } from 'module';
import { Buffer } from 'buffer';

fs.readFileSync = () => Buffer.from('Hello, ESM');
syncBuiltinESMExports();

fs.readFileSync === readFileSync;

импорт() выражений#
Динамический импорт() поддерживается как в модулях CommonJS, так и в ES. 
В модулях CommonJS его можно использовать для загрузки модулей ES.

импорт.мета#
<Объект>
Мета-свойство import.meta - это объект, содержащий следующие свойства.

импорт.мета.url#
<строка> Абсолютный файл: URL модуля.
Это определяется точно так же, как и в браузерах, предоставляющих URL-адрес текущего файла модуля.

Это позволяет использовать полезные шаблоны, такие как относительная загрузка файлов:

import { readFileSync } from 'fs';
const buffer = readFileSync(new URL('./data.proto', import.meta.url));

import.meta.resolve(specifier[, parent])
Стабильность: 1 - Экспериментальная
Эта функция доступна только при включенном флаге команды --experimental-import-meta-resolve.

указанный <строка> Модуль, указанный для разрешения относительно родительского.
родительский <строка> | <URL> Абсолютный URL родительского модуля для разрешения. 
Если ничего не указано, значение import.meta.url используется по умолчанию.
Возвращает: <Обещание>
Предоставляет функцию относительного разрешения модуля для каждого модуля, возвращающую строку URL.

const dependencyAsset = await import.meta.resolve('component-lib/asset.css');

import.meta.resolve также принимает второй аргумент, который является родительским модулем 
для разрешения из:

await import.meta.resolve('./dep', import.meta.url);

Эта функция является асинхронной, поскольку преобразователь модуля ES в Node.js 
допускается быть асинхронным.

Совместимость с
операторами импорта CommonJS##
Оператор импорта может ссылаться на модуль ES или модуль CommonJS. инструкции импорта 
разрешены только в модулях ES, но выражения динамического импорта() поддерживаются в 
CommonJS для загрузки модулей ES.

При импорте модулей CommonJS объект module.exports предоставляется в качестве экспорта по умолчанию. 
Могут быть доступны именованные экспортные данные, предоставляемые статическим анализом 
для удобства лучшей совместимости с экосистемой.

требовать#
Модуль CommonJS требует, чтобы файлы, на которые он ссылается, всегда обрабатывались как CommonJS.

Использование require для загрузки модуля ES не поддерживается, поскольку модули ES имеют 
асинхронное выполнение. Вместо этого используйте функцию import() для загрузки модуля ES из 
модуля CommonJS.

Пространства имен CommonJS#
Модули CommonJS состоят из объекта module.exports, который может быть любого типа.

При импорте модуля CommonJS его можно надежно импортировать с помощью импорта модуля ES 
по умолчанию или соответствующего синтаксиса sugar:

import { default as cjs } from 'cjs';

// The following import statement is "syntax sugar" (equivalent but sweeter)
// for `{ default as cjsSugar }` in the above import statement:
import cjsSugar from 'cjs';

console.log(cjs);
console.log(cjs === cjsSugar);
// Prints:
//   <module.exports>
//   true

Представление пространства имен модуля ECMAScript модуля CommonJS всегда является 
пространством имен с ключом экспорта по умолчанию, указывающим на значение модуля CommonJS.exports.

Этот экзотический объект пространства имен модуля можно напрямую наблюдать либо 
при использовании импорта * как m из 'cjs', либо при динамическом импорте:

import * as m from 'cjs';
console.log(m);
console.log(m === await import('cjs'));
// Prints:
//   [Module] { default: <module.exports> }
//   true

Для лучшей совместимости с существующим использованием в экосистеме JS, Node.js кроме того, 
предпринимаются попытки определить именованные экспорта CommonJS каждого импортированного 
модуля CommonJS, чтобы предоставить их в виде отдельных экспорта модулей ES с 
использованием процесса статического анализа.

Например, рассмотрим модуль CommonJS, написанный:
// cjs.cjs
exports.name = 'exported';

Предыдущий модуль поддерживает именованный импорт в модулях ES:

import { name } from './cjs.cjs';
console.log(name);
// Prints: 'exported'

import cjs from './cjs.cjs';
console.log(cjs);
// Prints: { name: 'exported' }

import * as m from './cjs.cjs';
console.log(m);
// Prints: [Module] { default: { name: 'exported' }, name: 'exported' }

Как видно из последнего примера регистрируемого экзотического объекта пространства имен модуля, 
экспорт имени копируется из объекта module.exports и устанавливается непосредственно в 
пространстве имен модуля ES при импорте модуля.

Обновления привязки в реальном времени или новые экспортные операции, добавленные в модуль. 
экспорт не обнаруживается для этих именованных экспортных операций.

Обнаружение именованных экспортных операций основано на общих синтаксических шаблонах, но не 
всегда правильно определяет именованные экспортные операции. В этих случаях лучшим вариантом 
может быть использование формы импорта по умолчанию, описанной выше.

Обнаружение именованных экспортов охватывает многие распространенные шаблоны экспорта, шаблоны 
реэкспорта, а также результаты инструментов построения и транспилятора. Точную реализованную 
семантику смотрите в cjs-module-lexer.

Различия между модулями ES и CommonJS#
Нет необходимости, экспорта или модуля.экспорт#
В большинстве случаев импорт модуля ES можно использовать для загрузки модулей CommonJS.

При необходимости функция require может быть создана в модуле ES с помощью module.createRequire().

Нет __имени файла или __имени файла#
Эти переменные CommonJS недоступны в модулях ES.

_варианты использования _filename и __dirname могут быть воспроизведены с помощью import.meta.url.

Нет загрузки модуля JSON#
Импорт JSON все еще является экспериментальным и поддерживается только с помощью флага 
--experimental-json-modules.

Локальные файлы JSON могут быть загружены относительно import.meta.url с помощью fs напрямую:

import { readFile } from 'fs/promises';
const json = JSON.parse(await readFile(new URL('./dat.json', import.meta.url)));

В качестве альтернативы можно использовать module.createRequire().

Нет Загрузки Встроенного Модуля#
Собственные модули в настоящее время не поддерживаются импортом модулей ES.

Вместо этого они могут быть загружены с помощью module.createRequire() или process.dlopen.

Не требуется.разрешать#
Относительное разрешение может быть обработано с помощью нового URL-адреса 
('./local', import.meta.url).

Для полной замены require.resolve существует помеченный экспериментальный API import.meta.resolve.

В качестве альтернативы можно использовать module.createRequire().

Нет ПУТИ К УЗЛУ#
NODE_PATH не является частью разрешения спецификаторов импорта. Пожалуйста, используйте 
символические ссылки, если такое поведение желательно.

Не требуется.расширения#
require.extensions не используется при импорте. Ожидается, что крючки загрузчика смогут 
обеспечить этот рабочий процесс в будущем.

Нет require.cache#
require.cache не используется при импорте, так как загрузчик модуля ES имеет свой собственный 
отдельный кэш.


Модули JSON#
Стабильность: 1 - Экспериментальная
В настоящее время импортируемые модули JSON поддерживаются только в режиме commonjs и 
загружаются с помощью загрузчика CJS. Спецификация модулей WHATWG JSON все еще стандартизирована 
и экспериментально поддерживается путем включения дополнительного флага 
--experimental-json-modules при запуске Node.js .

Когда включен флаг --experimental-json-modules, как в режиме commonjs, так и в режиме модуля 
используется новый экспериментальный загрузчик JSON. Импортированный JSON предоставляет 
только значение по умолчанию. Именованный экспорт не поддерживается. Запись кэша создается 
в кэше CommonJS, чтобы избежать дублирования. Тот же объект возвращается в CommonJS, если 
модуль JSON уже был импортирован по тому же пути.

Предполагая, что индекс.mjs с

import packageConfig from './package.json';

Флаг --experimental-json-modules необходим для работы модуля.

node index.mjs # fails
node --experimental-json-modules index.mjs # works

Модули Wsm#
Стабильность: 1 - Экспериментальная
Импорт модулей веб-сборки поддерживается под флагом --experimental-wasm-modules, разрешающим любые .файлы wasm должны быть импортированы как обычные модули, а также поддерживать импорт их модулей.

Эта интеграция соответствует предложению по интеграции модулей ES для веб-сборки.

Например, файл index.mjs, содержащий:

import * as M from './module.wasm';
console.log(M);

выполненный в соответствии:
node --experimental-wasm-modules index.mjs

предоставил бы интерфейс экспорта для создания экземпляра module.was.


Высший уровень ожидает#
Стабильность: 1 - Экспериментальная
Ключевое слово await может использоваться на верхнем уровне (за пределами асинхронных функций) в модулях в соответствии с предложением await верхнего уровня ECMAScript.

Предполагая, что a.mjs с

export const five = await Promise.resolve(5);

И b.mjs с
import { five } from './a.mjs';

console.log(five); // Logs `5`
node b.mjs # works

Погрузчики#
Стабильность: 1 - Экспериментальная
Примечание: Этот API в настоящее время пересматривается и все равно будет меняться.

Чтобы настроить разрешение модуля по умолчанию, крючки загрузчика могут быть 
дополнительно предоставлены с помощью аргумента --experimental-loader ./loader-name.mjs для Node.js .

Когда используются крючки, они применяются только к загрузке модуля ES, а не к любым 
загруженным модулям CommonJS.

Крючки#
разрешить(спецификатор, контекст, разрешение по умолчанию)#
Примечание: API загрузчиков подвергается переработке. Этот крючок может исчезнуть или его 
подпись может измениться. Не полагайтесь на API, описанный ниже.

спецификатор <строка>
контекст <Объект>
условия <строка[]>
Родительский элемент <строка> | <не определено>
defaultResolve <Функция> По умолчанию Node.js распознаватель по умолчанию.
Возвращает: <Объект>
формат <строка> | <null> | <не определено> 'встроенный' | 'commonjs' | 'json' | 'модуль' | 'wasm'
url <строка> Абсолютный URL-адрес цели импорта (например, файл://...)
Крючок разрешения возвращает разрешенный URL-адрес файла для заданного спецификатора модуля 
и родительского URL-адреса и, при необходимости, его формат (например, "модуль") в качестве 
подсказки для крючка загрузки. Если указан формат, крючок загрузки в конечном счете отвечает 
за предоставление окончательного значения формата (и он может игнорировать подсказку, 
предоставленную resolve); если resolve предоставляет формат, требуется пользовательский 
крючок загрузки, даже если только для передачи значения в Node.js крючок для загрузки по умолчанию.

Спецификатор модуля - это строка в инструкции импорта или выражении import(), а родительский 
URL-адрес - это URL-адрес модуля, который импортировал этот модуль, или не определен, 
если это основная точка входа для приложения.

Свойство conditions в контексте представляет собой набор условий для условий экспорта пакетов, 
которые применяются к этому запросу на разрешение. Их можно использовать для поиска условных 
сопоставлений в другом месте или для изменения списка при вызове логики разрешения по умолчанию.

Текущие условия экспорта пакета всегда находятся в массиве context.conditions, переданном в крючок. 
Чтобы гарантировать дефолт Node.js поведение разрешения спецификатора модуля при вызове 
defaultResolve массив context.conditions, переданный ему, должен включать все элементы массива 
context.conditions, первоначально переданного в крючок разрешения.

/**
 * @param {string} specifier
 * @param {{
 *   conditions: !Array<string>,
 *   parentURL: !(string | undefined),
 * }} context
 * @param {Function} defaultResolve
 * @returns {Promise<{ url: string }>}
 */
export async function resolve(specifier, context, defaultResolve) {
  const { parentURL = null } = context;
  if (Math.random() > 0.5) { // Some condition.
    // For some or all specifiers, do some custom logic for resolving.
    // Always return an object of the form {url: <string>}.
    return {
      url: parentURL ?
        new URL(specifier, parentURL).href :
        new URL(specifier).href,
    };
  }
  if (Math.random() < 0.5) { // Another condition.
    // When calling `defaultResolve`, the arguments can be modified. In this
    // case it's adding another value for matching conditional exports.
    return defaultResolve(specifier, {
      ...context,
      conditions: [...context.conditions, 'another-condition'],
    });
  }
  // Defer to Node.js for all other specifiers.
  return defaultResolve(specifier, context, defaultResolve);
}

загрузка (url, контекст, загрузка по умолчанию)#
Примечание: API загрузчиков подвергается переработке. Этот крючок может исчезнуть или его 
подпись может измениться. Не полагайтесь на API, описанный ниже.

Примечание: В предыдущей версии этого API это было разделено на 3 отдельных, теперь устаревших 
крючка (getFormat, getSource и transformSource).

url-адрес <строка>
контекст <Объект>
формат <строка> | <нуль> | <не определено> Формат, опционально предоставляемый крючком разрешения.
Загрузка по умолчанию <Функция>
Возвращает: <Объект>
формат <строка>
источник <строка> | <Буфер массива> | <Массив типов>
Крючок загрузки предоставляет способ определения пользовательского метода определения того, 
как URL-адрес должен интерпретироваться, извлекаться и анализироваться.

Конечное значение формата должно быть одним из следующих:

описание формата Допустимые типы для источника, возвращаемого загрузкой
"встроенной" загрузки a Node.js встроенный модуль неприменим
'commonjs' Загружает Node.js Модуль CommonJS неприменим
'json' Загружает файл JSON { строка, буфер массива, массив типов }
"модуль" Загружает модуль ES { строка, МассиВбуфер, массив типов }
'wasm' Загружает модуль WebAssembly { буфер массива, TypedArray }
Значение источника игнорируется для типа "встроенный", поскольку в настоящее время невозможно 
заменить значение Node.js встроенный (основной) модуль. Значение source игнорируется для 
типа 'commonjs', поскольку загрузчик модуля CommonJS не предоставляет загрузчику модуля ES 
механизма переопределения возвращаемого значения модуля CommonJS. Это ограничение может быть 
преодолено в будущем.

Предостережение: Крючок загрузки ESM и экспорт с пространством имен из модулей CommonJS несовместимы. 
Попытка использовать их вместе приведет к появлению пустого объекта при импорте. 
Этот вопрос может быть решен в будущем.

Примечание: Все эти типы соответствуют классам, определенным в ECMAScript.

Конкретный объект ArrayBuffer является общим буфером массива.
Конкретный объект TypedArray является Uint8Array.
Если исходное значение текстового формата (например, 'json', 'модуль') не является строкой, 
оно преобразуется в строку с помощью util.Текстовый декодер.

Крючок загрузки предоставляет способ определения пользовательского метода для извлечения 
исходного кода спецификатора модуля ES. Это позволило бы загрузчику потенциально избежать 
чтения файлов с диска. Его также можно использовать для сопоставления нераспознанного формата с 
поддерживаемым, например yaml с модулем.

/**

/**
 * @param {string} url
 * @param {{
    format: string,
  }} context If resolve settled with a `format`, that value is included here.
 * @param {Function} defaultLoad
 * @returns {Promise<{
    format: !string,
    source: !(string | ArrayBuffer | SharedArrayBuffer | Uint8Array),
  }>}
 */
export async function load(url, context, defaultLoad) {
  const { format } = context;
  if (Math.random() > 0.5) { // Some condition.
    /*
      For some or all URLs, do some custom logic for retrieving the source.
      Always return an object of the form {
        format: <string>,
        source: <string|buffer>,
      }.
    */
    return {
      format,
      source: '...',
    };
  }
  // Defer to Node.js for all other URLs.
  return defaultLoad(url, context, defaultLoad);
}

В более продвинутом сценарии это также может быть использовано для преобразования 
неподдерживаемого источника в поддерживаемый (см. Примеры ниже).

глобальная предварительная нагрузка()#
Примечание: API загрузчиков подвергается переработке. Этот крючок может исчезнуть или его 
подпись может измениться. Не полагайтесь на API, описанный ниже.

Примечание: В предыдущей версии этого API этот хук назывался getGlobalPreloadCode.

Возвращает: <строка>
Иногда может потребоваться запустить некоторый код внутри той же глобальной области, в 
которой работает приложение. Этот крючок позволяет возвращать строку, которая запускается 
как сценарий неаккуратного режима при запуске.

Подобно тому, как работают оболочки CommonJS, код выполняется в области неявной функции. 
Единственным аргументом является функция, подобная требованию, которая может использоваться 
для загрузки встроенных функций, таких как "fs": getBuildin(запрос: строка).

Если коду требуются более продвинутые функции require, он должен создать свой собственный 
require с помощью module.createRequire().

/**
 * @returns {string} Code to run before application startup
 */
export function globalPreload() {
  return `\
globalThis.someInjectedProperty = 42;
console.log('I just set some globals!');

const { createRequire } = getBuiltin('module');
const { cwd } = getBuiltin('process');

const require = createRequire(cwd() + '/<preload>');
// [...]
`;
}

Примеры#
Различные крюки погрузчика могут использоваться вместе для выполнения широкого спектра 
настроек Node.js ’ поведение при загрузке и оценке кода.

Загрузчик HTTPS#
В текущем Node.js , спецификаторы, начинающиеся с https://, не поддерживаются. Загрузчик 
ниже регистрирует крючки, чтобы обеспечить элементарную поддержку таких спецификаторов. 
Хотя это может показаться значительным улучшением для Node.js основная функциональность, 
у фактического использования этого загрузчика есть существенные недостатки: производительность 
намного медленнее, чем загрузка файлов с диска, отсутствует кэширование и отсутствует безопасность.

// https-loader.mjs
import { get } from 'https';

export function resolve(specifier, context, defaultResolve) {
  const { parentURL = null } = context;

  // Normally Node.js would error on specifiers starting with 'https://', so
  // this hook intercepts them and converts them into absolute URLs to be
  // passed along to the later hooks below.
  if (specifier.startsWith('https://')) {
    return {
      url: specifier
    };
  } else if (parentURL && parentURL.startsWith('https://')) {
    return {
      url: new URL(specifier, parentURL).href
    };
  }

  // Let Node.js handle all other specifiers.
  return defaultResolve(specifier, context, defaultResolve);
}

export function load(url, context, defaultLoad) {
  // For JavaScript to be loaded over the network, we need to fetch and
  // return it.
  if (url.startsWith('https://')) {
    return new Promise((resolve, reject) => {
      get(url, (res) => {
        let data = '';
        res.on('data', (chunk) => data += chunk);
        res.on('end', () => resolve({
          // This example assumes all network-provided JavaScript is ES module
          // code.
          format: 'module',
          source: data,
        }));
      }).on('error', (err) => reject(err));
    });
  }

  // Let Node.js handle all other URLs.
  return defaultLoad(url, context, defaultLoad);
}
// main.mjs
import { VERSION } from 'https://coffeescript.org/browser-compiler-modern/coffeescript.js';

console.log(VERSION);

С предыдущим загрузчиком, запущенным узлом --экспериментальный загрузчик ./https-loader.js 
./main.mjs печатает текущую версию CoffeeScript для каждого модуля по URL-адресу в main.mjs.

Погрузчик-транспилер#
Источники, которые находятся в форматах Node.js не понимает, может быть преобразован в 
JavaScript с помощью крючка загрузки. Однако, прежде чем этот крючок будет вызван, крючок 
разрешения должен сообщить Node.js чтобы не выдавать ошибку при неизвестных типах файлов.

Это менее эффективно, чем перенос исходных файлов перед запуском Node.js ; загрузчик 
транспайлера следует использовать только для целей разработки и тестирования.

// coffeescript-loader.mjs
import { readFile } from 'node:fs/promises';
import { dirname, extname, resolve as resolvePath } from 'node:path';
import { cwd } from 'node:process';
import { fileURLToPath, pathToFileURL } from 'node:url';
import CoffeeScript from 'coffeescript';

const baseURL = pathToFileURL(`${cwd()}/`).href;

// CoffeeScript files end in .coffee, .litcoffee or .coffee.md.
const extensionsRegex = /\.coffee$|\.litcoffee$|\.coffee\.md$/;

export async function resolve(specifier, context, defaultResolve) {
  const { parentURL = baseURL } = context;

  // Node.js normally errors on unknown file extensions, so return a URL for
  // specifiers ending in the CoffeeScript file extensions.
  if (extensionsRegex.test(specifier)) {
    return {
      url: new URL(specifier, parentURL).href
    };
  }

  // Let Node.js handle all other specifiers.
  return defaultResolve(specifier, context, defaultResolve);
}

загрузка асинхронной функции экспорта (url, контекст, загрузка по умолчанию) {
  // Теперь, когда мы исправили разрешение пропускать URL-адреса CoffeeScript, нам нужно
  // рассказать Node.js в каком формате следует интерпретировать такие URL-адреса. Потому что
  // CoffeeScript переносится в JavaScript, он должен быть одним из двух
  // Форматы JavaScript: 'commonjs' или 'модуль'.
  если (extensionsRegex.test(url)) {
    / Файлы / CoffeeScript могут быть модулями CommonJS или ES, поэтому мы хотим, чтобы любой
файл // CoffeeScript обрабатывался Node.js такой же, как файл .js в
    // в том же месте. Чтобы определить, как Node.js будет интерпретировать произвольный .js
    // файл, найдите в файловой системе ближайший родительский файл package.json.
    // и прочитайте его поле "тип".
    формат const = ожидание получения типа пакета(url);
    // Когда хук возвращает формат 'commonjs', `источник` игнорируется.
    // Для обработки файлов CommonJS обработчик должен быть зарегистрирован в
    // `требуются расширения" для обработки файлов с помощью CommonJS
    // погрузчик. Избавление от необходимости в отдельном обработчике CommonJS - это будущее
    // планируется усовершенствование загрузчиков модулей ES.
    если (формат === 'commonjs') {
      возврат { формат };
    }

    const { источник: rawsource } = ожидание загрузки по умолчанию(url, { формат });
    // Этот крючок преобразует исходный код CoffeeScript в исходный код JavaScript
    // для всех импортированных файлов CoffeeScript.
    const преобразованный источник = CoffeeScript.компиляция(исходный источник.toString(), {
      голый: верно,
имя файла: url,
    });

    возвращение {
      формат,
источник: Преобразованный источник,
    };
  }

  // Пусть Node.js обрабатывайте все остальные URL-адреса.
  вернуть загрузку по умолчанию (url, контекст, загрузка по умолчанию);
}

асинхронная функция getPackageType(url) {
  // `url` - это только путь к файлу во время первой итерации, когда передается
  // разрешен URL-адрес из крючка load()
  // фактический путь к файлу из load() будет содержать расширение файла, поскольку оно
  // требуется в соответствии со спецификацией
  // эта простая правдивая проверка того, содержит ли "url" расширение файла, будет
  // работает для большинства проектов, но не охватывает некоторые крайние случаи (такие как
  // файлы без расширений или URL-адрес, заканчивающийся пробелом)
  const isFilePath = !!имя файла(url);
  // Если это путь к файлу, найдите каталог, в
котором он находится, const dir = isFilePath ?
    имя файла(путь к файлу(url)) :
    URL-адрес;
  // Создайте путь к файлу package.json в том же каталоге,
// который может существовать, а может и не существовать
const packagePath = resolvePath(каталог, 'package.json');
  // Попробуйте прочитать, возможно, несуществующий пакет.json
const type = ожидающий файл для чтения(путь к пакету, { кодировка: 'utf8' })
    .затем((строка файла) => JSON.синтаксический анализ(строка файла).тип)
    .поймать((ошибка) => {
      если (ошибка?.код !== 'ENOENT') консоль.ошибка(ошибка);
    });
  // Ff package.json существовал и содержал поле "тип" со значением, вуаля
  если (тип) возвращаемый тип;
  // В противном случае (если не в корне) продолжайте проверять следующий каталог вверх
  // Если в корне, остановитесь и верните false
, верните dir.длина > 1 && getPackageType(путь разрешения(dir, '..'));
}

# main.coffee
import { scream } from './scream.coffee'
console.log scream 'hello, world'

import { version } from 'process'
console.log "Brought to you by Node.js version #{version}"
# scream.coffee
export scream = (str) -> str.toUpperCase()

С предыдущим загрузчиком, запущенным узлом --экспериментальный загрузчик 
./coffeescript-loader.js main.coffee приводит к превращению main.coffee в JavaScript 
после загрузки его исходного кода с диска, но до Node.js выполняет его; и так далее 
для любого .кофе, .кофе или .coffee.md файлы, на которые ссылаются с помощью инструкций 
импорта любого загруженного файла.

Алгоритм разрешения#
Особенности#
Распознаватель обладает следующими свойствами:

Разрешение на основе файлов, используемое модулями ES
Поддержка загрузки встроенных модулей
Относительное и абсолютное разрешение URL-адресов
Нет расширений по умолчанию
Нет сети папок
Поиск разрешения пакета с пустым спецификатором через node_modules
Алгоритм распознавания#
Алгоритм загрузки спецификатора модуля ES приведен ниже с помощью метода ESM_RESOLVE. 
Он возвращает разрешенный URL-адрес для спецификатора модуля относительно родительского элемента.

Алгоритм определения формата модуля разрешенного URL-адреса предоставляется ESM_FORMAT, 
который возвращает уникальный формат модуля для любого файла. Формат "модуль" возвращается 
для модуля ECMAScript, в то время как формат "commonjs" используется для указания загрузки 
через устаревший загрузчик CommonJS. Дополнительные форматы, такие как "аддон", могут быть 
расширены в будущих обновлениях.

В следующих алгоритмах все ошибки подпрограмм распространяются как ошибки этих подпрограмм 
верхнего уровня, если не указано иное.

defaultConditions - это массив условных имен среды ["узел", "импорт"].

Распознаватель может выдавать следующие ошибки:

Недопустимый спецификатор модуля: Спецификатор модуля - это недопустимый URL-адрес, имя пакета 
или спецификатор пути к пакету.
Недопустимая конфигурация пакета: конфигурация package.json недопустима или содержит 
недопустимую конфигурацию.
Недопустимый целевой пакет. Экспорт или импорт пакета определяет целевой модуль для пакета, 
который является недопустимым типом или строковой целью.
Путь к пакету Не экспортирован: Экспорт пакетов не определяет и не разрешает целевой подпут 
в пакете для данного модуля.
Импорт пакета не определен: Импорт пакета не определяет спецификатор.
Модуль не найден: Запрошенный пакет или модуль не существует.
Импорт неподдерживаемого каталога: Разрешенный путь соответствует каталогу, который не является 
поддерживаемым целевым объектом для импорта модулей.

Спецификация алгоритма распознавания#
ESM_RESOLVE(спецификатор, родительский элемент)

Пусть разрешенный будет неопределенным.
Если спецификатор является допустимым URL-адресом, то
Установите разрешенный результат синтаксического анализа и повторной сериализации 
спецификатора в качестве URL-адреса.
В противном случае, если спецификатор начинается с "/", "./" или "../", то
Установите разрешение на разрешение URL-адреса спецификатора относительно parentURL.
В противном случае, если спецификатор начинается с "#", то
Установите разрешенное значение на разрушенное значение результата 
PACKAGE_IMPORTS_RESOLVE(спецификатор, родительский элемент, условия по умолчанию).
Иначе,
Примечание: спецификатор теперь является простым спецификатором.
Набор разрешил результат PACKAGE_RESOLVE(спецификатор, родительский элемент).
Если разрешение содержит какие-либо процентные кодировки "/" или "\" ("%2f" и "%5C" соответственно), 
то
Выдает ошибку недопустимого спецификатора модуля.
Если разрешенный файл является каталогом, то
Выдает ошибку импорта неподдерживаемого каталога.
Если разрешенный файл не существует, то
Выдает ошибку "Модуль не найден".
Установите "решено" на реальный путь "решено".
Пусть формат будет результатом ESM_FORMAT(разрешен).
Загрузка разрешена как формат модуля, формат.
Возвращение решено.
PACKAGE_RESOLVE(идентификатор пакета, родительский элемент)

Пусть имя пакета не определено.
Если packageSpecifier является пустой строкой, то
Выдает ошибку недопустимого спецификатора модуля.
Если спецификатор пакета не начинается с "@", то
Установите имя пакета в подстроку спецификатора пакета до первого разделителя "/" или конца строки.
Иначе,
Если определитель упаковки не содержит разделителя "/", то
Выдает ошибку недопустимого спецификатора модуля.
Установите имя пакета в подстроку спецификатора пакета до второго разделителя "/" или конца строки.
Если имя пакета начинается с "." или содержит "\" или "%", то
Выдает ошибку недопустимого спецификатора модуля.
Пусть packageSubpath будет "." объединен с подстрокой packagespecifier из позиции по длине 
имени пакета.
Пусть SELFURL будет результатом PACKAGE_SELF_RESOLVE(PACKAGENAME, packagesubpath, parenturl).
Если selfUrl не определен, верните selfUrl.
Если путь к пакетам равен ".", а имя пакета равно Node.js встроенный модуль, затем
Возвращает строку "узел:", объединенную с определителем пакета.
В то время как parentURL не является корнем файловой системы,
Пусть packageurl будет разрешением URL-адреса "node_modules/", объединенного с определителем пакета, 
относительно PARENTURL.
Установите parentURL в URL-адрес родительской папки parentURL.
Если папка в packageURL не существует, то
Установите parentURL в родительский URL-адрес parentURL.
Продолжайте следующую итерацию цикла.
Пусть pjson будет результатом READ_PACKAGE_JSON(PACKAGEURL).
Если значение pjson не равно нулю, а значение pjson.exports не равно нулю или не определено, то
Пусть экспорт будет pjson.экспорт.
Возвращает разрешенное деструктурированное значение результата PACKAGE_EXPORTS_RESOLVE(PACKAGEURL, 
packagesubpath, pjson.exports, условия по умолчанию).
В противном случае, если путь к пакетам равен ".", то
Верните результат, применив устаревший преобразователь LOAD_AS_DIRECTORY CommonJS к packageurl, 
выдав ошибку "Модуль не найден" без разрешения.
В противном случае
верните разрешение URL-адреса packageSubpath в Packageurl.
Выдает ошибку "Модуль не найден".
PACKAGE_SELF_RESOLVE(имя пакета, путь к пакетам, родительский элемент)
Пусть packageurl будет результатом READ_PACKAGE_SCOPE(PARENTURL).
Если packageURL равен нулю, то
Возврат не определен.
Пусть pjson будет результатом READ_PACKAGE_JSON(PACKAGEURL).
Если значение pjson равно нулю или если значение pjson.exports равно нулю или не определено, то
Возврат не определен.
Если pjson.name равно имени пакета, тогда
Возвращает разрешенное деструктурированное значение результата PACKAGE_EXPORTS_RESOLVE(PACKAGEURL, packagesubpath, pjson.exports, условия по умолчанию).
В противном случае верните значение undefined.
PACKAGE_EXPORTS_RESOLVE(список пакетов, подпуть, экспорт, условия)

Если экспортируется объект с ключом, начинающимся с ".", и ключом, не начинающимся с ".", выдает недопустимую ошибку конфигурации пакета.
Если подпуть равен ".", то
Пусть mainExport не определен.
Если экспорт представляет собой строку или массив или объект, не содержащий ключей, начинающихся с ".", то
Установите значение mainExport в значение экспорт.
В противном случае, если экспорт является объектом, содержащим свойство ".", то
Установите значение mainExport для экспорта["."].
Если mainExport не определен, то
Пусть resolved будет результатом PACKAGE_TARGET_RESOLVE( PACKAGEURL, основной экспорт, "", ложь, ложь, условия).
Если значение resolved не равно нулю или не определено, то
Возвращение решено.
В противном случае, если экспорт является объектом и все ключи экспорта начинаются с ".", то
Пусть ключом совпадения будет строка "./", объединенная с подпутью.
Пусть разрешенное соответствие будет результатом PACKAGE_IMPORTS_EXPORTS_RESOLVE(ключ соответствия, экспорт, packageurl, ложь, условия).
Если resolvedMatch.resolve не равно нулю или не определено, то
Верните разрешенное соответствие.
Выдает ошибку "Путь к пакету не экспортирован".
PACKAGE_IMPORTS_RESOLVE(спецификатор, родительский элемент, условия)

Утверждение: спецификатор начинается с "#".
Если спецификатор в точности равен "#" или начинается с "#/", то
Выдает ошибку недопустимого спецификатора модуля.
Пусть packageurl будет результатом READ_PACKAGE_SCOPE(PARENTURL).
Если packageURL не равен нулю, то
Пусть pjson будет результатом READ_PACKAGE_JSON(PACKAGEURL).
Если pjson.imports является ненулевым объектом, то
Пусть разрешенное соответствие будет результатом PACKAGE_IMPORTS_EXPORTS_RESOLVE(спецификатор, pjson.imports, packageurl, true, условия).
Если resolvedMatch.resolve не равно нулю или не определено, то
Верните разрешенное соответствие.
Выдает ошибку "Импорт пакета не определен".
PACKAGE_IMPORTS_EXPORTS_RESOLVE(ключ соответствия, matchobj, packageurl, ISIMPORTS, условия)

Если matchKey является ключом matchObj и не заканчивается на "/" или содержит "*", то
Пусть целью будет значение matchObj[Ключ соответствия].
Пусть resolved будет результатом PACKAGE_TARGET_RESOLVE( PACKAGEURL, цель, "", ложь, ISIMPORTS, условия).
Возвращает объект { разрешен, точный: истина }.
Пусть EXPANSIONKEYS - это список ключей matchobj, либо заканчивающийся на "/", либо содержащий только один "*", отсортированный функцией сортировки PATTERN_KEY_COMPARE, которая упорядочивается в порядке убывания специфичности.
Для каждого ключа расширения в разделе Ключи расширения выполните
Пусть база шаблонов равна нулю.
Если ключ расширения содержит "*", установите базу шаблонов в подстроку ключа расширения до, но исключая первый символ "*".
Если база шаблонов не равна нулю, а ключ соответствия начинается с, но не равен базе шаблонов, то
Если ключ совпадения заканчивается на "/", выдает ошибку недопустимого спецификатора модуля.
Пусть patternTrailer будет подстрокой ключа расширения из индекса после первого символа "*".
Если patternTrailer имеет нулевую длину или если ключ соответствия заканчивается на patternTrailer, а длина ключа соответствия больше или равна длине ключа расширения, то
Пусть целью будет значение matchObj[Ключ расширения].
Пусть подпуть - это подстрока ключа соответствия, начинающаяся с индекса длины базы шаблонов до длины ключа соответствия минус длина трейлера шаблонов.
Пусть resolved будет результатом PACKAGE_TARGET_RESOLVE( PACKAGEURL, цель, подпуть, истина, ISIMPORTS, условия).
Возвращает объект { разрешен, точный: истина }.
В противном случае, если база шаблонов равна нулю, а ключ соответствия начинается с ключа расширения, то
Пусть целью будет значение matchObj[Ключ расширения].
Пусть подпуть - это подстрока ключа соответствия, начинающаяся с индекса длины ключа расширения.
Пусть resolved будет результатом PACKAGE_TARGET_RESOLVE( PACKAGEURL, цель, подпуть, ложь, ISIMPORTS, условия).
Возвращает объект { разрешен, точный: ложь }.
Возвращает объект { разрешено: null, точно: истина }.
ШАБЛОН___КОМПАРАТ(кейя, кейб)

Утверждение: кея заканчивается на "/" или содержит только один "*".
Утверждение: keyB заканчивается на "/" или содержит только один "*".
Пусть базовая длина будет индексом "*" в кее плюс один, если кея содержит "*", или длиной кея в противном случае.
Пусть baseLengthB будет индексом "*" в KEYB плюс один, если KEYB содержит "*", или длиной KEYB в противном случае.
Если базовая длина больше базовой длины B, верните значение -1.
Если базовая длинаb больше базовой длины, верните 1.
Если ключ не содержит "*", верните 1.
Если keyB не содержит "*", верните значение -1.
Если длина ключа больше длины ключа B, верните значение -1.
Если длина keyB больше длины keyA, верните 1.
Вернуть 0.
PACKAGE_TARGET_RESOLVE(список пакетов, цель, подпуть, шаблон, внутренний, условия)

Если цель - строка, то
Если шаблон ложен, подпуть имеет ненулевую длину, а цель не заканчивается на "/", выдает ошибку недопустимого спецификатора модуля.
Если цель не начинается с "./", то
Если значение internal равно true, а цель не начинается с "../" или "/" и не является допустимым URL-адресом, то
Если шаблон верен, то
Возвращает PACKAGE_RESOLVE(цель с каждым экземпляром "*", замененным подпутем, PACKAGEURL + "/")_.
Возвращает PACKAGE_RESOLVE(цель + подпуть, PACKAGEURL + "/")_.
В противном случае выдаст ошибку недопустимого целевого пакета.
Если целевой раздел на "/" или "\" содержит какие-либо сегменты ".", ".." или "node_modules" после первого сегмента, выдает недопустимую ошибку целевого пакета.
Пусть resolvedTarget будет разрешением URL для объединения packageURL и target.
Утверждение: Разрешенный таргет содержится в packageURL.
Если подпуть, разделенный на "/" или "\", содержит какие-либо сегменты ".", ".." или "node_modules", выдает ошибку недопустимого спецификатора модуля.
Если шаблон верен, то
Верните разрешение URL-адреса resolvedTarget с каждым экземпляром "*", замененным на подпуть.
Иначе,
Возвращает разрешение URL-адреса для объединения подпутя и разрешенного таргета.
В противном случае, если цель является ненулевым объектом, то
Если экспорт содержит какие-либо ключи свойств индекса, как определено в ECMA-262 6.1.7 Индекс массива, выдает недопустимую ошибку конфигурации пакета.
Для каждого свойства p цели, в порядке вставки объекта, как,
Если p равно "по умолчанию" или условия содержат запись для p, то
Пусть targetValue будет значением свойства p в target.
Пусть resolved будет результатом PACKAGE_TARGET_RESOLVE( PACKAGEURL, целевое значение, подпуть, шаблон, внутренний, условия).
Если значение resolved равно значению undefined, продолжайте цикл.
Возвращение решено.
Возврат не определен.
В противном случае, если целью является массив, то
Если _target.длина равна нулю, возвращайте значение null.
Для каждого целевого значения элемента в target выполните
Пусть resolved будет результатом PACKAGE_TARGET_RESOLVE( PACKAGEURL, целевое значение, подпуть, шаблон, внутренний, условия), продолжающий цикл при любой недопустимой ошибке целевого пакета.
Если значение resolved не определено, продолжайте цикл.
Возвращение решено.
Верните или выбросьте последнее резервное разрешение нулевого возврата или ошибки.
В противном случае, если цель равна нулю, верните значение null.
В противном случае возникает ошибка недопустимого целевого пакета.
ФОРМАТ ESM_FORMAT(url)

Утверждение: url-адрес соответствует существующему файлу.
Пусть pjson будет результатом READ_PACKAGE_SCOPE(url).
Если URL заканчивается на ".mjs", то
Верните "модуль".
Если URL заканчивается на ".cjs", то
Верните "commonjs".
Если пиджсон?.тип существует и является "модулем", тогда
Если URL заканчивается на ".js", то
Верните "модуль".
Выдает ошибку с неподдерживаемым расширением файла.
В противном случае
выдаст ошибку с неподдерживаемым расширением файла.
READ_PACKAGE_SCOPE(url-адрес)

Пусть scopeURL будет url-адресом.
В то время как scopeURL не является корнем файловой системы,
Установите scopeURL в качестве родительского URL-адреса scopeURL.
Если scopeURL заканчивается сегментом пути "node_modules", верните значение null.
Пусть pjson будет результатом READ_PACKAGE_JSON(SCOPEURL).
Если pjson не равен нулю, то
Верните пижаму.
Возвращает значение null.
READ_PACKAGE_JSON(список пакетов)

Пусть pjsonURL будет разрешением "package.json" в packageurl.
Если файл в pjsonURL не существует, то
Возвращает значение null.
Если файл в packageURL не анализируется как допустимый JSON, то
Выдает недопустимую ошибку конфигурации пакета.
Верните проанализированный источник JSON файла в pjsonURL.

Настройка алгоритма разрешения спецификатора ESM#
Стабильность: 1 - Экспериментальная
Текущее указанное разрешение не поддерживает все поведение загрузчика CommonJS по умолчанию. 
Одним из отличий в поведении является автоматическое разрешение расширений файлов и возможность 
импорта каталогов с индексным файлом.

Флаг --experimental-specifier-разрешение=[режим] можно использовать для настройки алгоритма 
разрешения расширения. Режим по умолчанию является явным, который требует, чтобы загрузчику 
был предоставлен полный путь к модулю. Чтобы включить автоматическое разрешение расширений 
и импорт из каталогов, содержащих индексный файл, используйте режим узла.

$ node index.mjs
success!
$ node index # Failure!
Error: Cannot find module
$ node --experimental-specifier-resolution=node index
success!