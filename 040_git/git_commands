
# HELP
git <команда> --help
git <команда> -h     # Посмотреть только список опций
man git-<команда>
git help <команда>

# НАСТРОЙКИ GIT
git --version     # Смотреть версию гита
git config --list --show-origin   # см. настройки + их расположение
git config --<option> <param> <value>       # устан. новое значение парам.
    --system    # на уровне системы (для всех пользователей)   /etc/gitconfig
    --global    # на уровне одного пользователя (для всех проектов)   ~/.gitconfig
    --local     # на уровне одного проекта (default)   <project>/.git/config
git config --global user.name 'John Doe'    # устан. имя польз-ля
git config --unset user.name                # удалить параметр
git config --remove-section user            # удалить всю секцию параметра
git config --global alias.ca '!git add .;git commit' #сделать алиас для 'add + commit'
git config --global core.excludesFile ~/.gitexcludes  # исключения для компьютера
git config --global core.editor "code --wait" # установить редактор vscode
git config --global core.editor "nano -w"
git config --global core.editor "kate"

# ПРАВА
git config core.fileMode false              # на права смотреть не надо (в режиме 644)
# сделать исполнимым файл напрямую в индексе (обычно из под windows):
git upate-index --chmode=+x index.html
# или если файла ещё нет в индексе:
git add --chmod=+x <file>

# ИНИЦИАЛИЗАЦИЯ   
git init  # созд. дир. .git с начальн. настройками
# Содержание дир. .git
    HEAD      # указывает на текущий коммит в рабоч. области
    hooks/    # запуск пользовательских скриптов по событиям
    info/     # глоб. настройки игнор. файлов (если не нужны в .gitignore)
    objects/  # база данных объектов Git
    refs/     # ссылки на объекты коммитов в этой базе
    index     # хранится содержимое индекса
    ...

# КЛОНИРОВАНИЕ
git clone <ссылка> dir1     # клонир. в каталог dir1 (по умол. в текущ.)
git svn clone -s <ссылка>   # клонир. svn репо
    -s – понимать стандартные папки SVN (trunk, branches, tags)
    <ссылка> м.б.:
        https://...
        /home/username/...
        ssh://...
        git://...

# ЗАБРАТЬ ИЗМЕНЕНИЯ ИЗ РЕПО
git fetch <адрес>   # забир. измен. удаленной ветки (но без слияния!!!)
# после оценки изменений (git diff), надо создать коммит слияния с основной:
git merge origin/develop      # созд. коммит слияния
git pull                      # fetch + merge
git pull --rebase <адрес>     # вместо "git merge" испол-ся "git rebase"
git pull --no-commit <адрес>  # без создания нового коммита

# ОТПРАВИТЬ ИЗМЕНЕНИЯ В УДАЛЕННЫЙ РЕПО
git push --set-upstream origin main   # связать тек. ветку с удален.
git push <remote-name> <branch-name>
git push origin main                  # запушить изменения на удален. репо
git push origin master -f             # принудительно запушить (опасно)
git push origin master --tags         # Отправляет метки
git push origin origin/develop:master # Изменяет указатель для удаленной ветке
# Добавляет ветку test в удаленный репозиторий origin, указывающую на коммит ветки develop:
git push origin origin/develop:refs/heads/test

# REBASE (последоват-е наложение ком-в одной ветки на последн. коммит другой ветки)
git rebase master topic  # коммиты из topic (по умол. текущ.) наклад. на послед. коммит master 
    --continue    # продолжить наложение после разрешения проблем
    --skip        # пропустить наложение коммита и перейти к следующему
    --abort       # отмена команды и изменений (вернёт HEAD)
    --quit        # отмена команды и изменений (не вернёт HEAD)
# Синхронизация с main центрального репозитория, используя перебазирование:
    git checkout main
    git pull --rebase origin


# УДАЛЕННОЕ ПОДКЛЮЧЕНИЕ К РЕПО
git remote                  # см. репозитории
git remote -v               # см. репозитории + их url
git remote show upstream    # подробн. вывод о конфигурации удал. репо
git remote add origin <url> # созд. нов. подключения к удал. репо
git remote rm <name>        # удаляет подключение 
git remote rename <old-name> <new-name>   # переимен. удален. подключения 

# ПРОВЕРИТЬ СОСТОЯНИЕ ФАЙЛОВ
git status
git status -s       # Сокращенный вывод статуса
git status --short  # то же самое

# ПРОИНДЕКСИРОВАТЬ
git add README  
    # добав. в гит 
    # проиндексир. /
    # указ. файл, исправленный в конфликте слияния
git add *           # добавить всё в текущем каталоге
git add .           # добавить всё в текущем каталоге
git add -a          # добавить всё в текущем каталоге
git add -A          # добавить всё, начиная с корня проекта
git add -f <file>   # добавить в индекс файл в гит-игноре

# ЗАФИКСИРОВАТЬ ИЗМЕНЕНИЯ
git commit <file> # зафикс. изменения, вызвав редактор (если указ. явно <file>, то можно неиндексир.)
git commit -m "comment" # набрать свой комментарий к коммиту
git commit -m "comment" <file> # заком. отдельный файл (даже непроиндекс-й)
git commit -a           # add + commit
git commit -v           # перед коммитом подробн. инф.
# ПЕРЕЗАПИСАТЬ КОММИТ:
git commit --amend -m "Add an author/email comment" # перезаписать коммит

# ВЗЯТЬ КОММИТ ИЗ ДРУГОЙ ВЕТКИ ИЛИ БЕЗ ВЕТКИ
git cherry-pick <hash> # скопировать коммит(ы) на тек. ветку
git cherry-pick BUG_FIX_TAG     # автоматически проиндексированы и станут коммитом
git cherry-pick BUG_FIX_TAG -n  # без индексации и создания коммита

# ПЕРЕМЕСТИТЬ / ПЕРЕИМЕНОВАТЬ ФАЙЛ
git mv README.md README  # переименовать файл из README.md в README

# ВРЕМЕННОЕ ИГНОРИРОВАНИЕ ФАЙЛОВ
git update-index --assume-unchanged <file>     # игнорировать <file>
git update-index --no-assume-unchanged <file>  # отключить игнорирование

# СМОТРЕТЬ ОТЛИЧИЯ
git show <tag|hash> # показать изменения, внесенные отдельным коммитом
git show            # показать изменения из HEAD
git diff            # по сравнению с последним коммитом
git diff HEAD^      # Предпоследним коммитом
git diff f292ef5    # разница тек. состояния проекта и указ. коммита
git diff --staged   # Изменения, внесенные в индекс
git diff --cached   # Изменения, внесенные в индекс. Синоним --staged
git diff stable-1.1...stable-1  # разница, используя теги
git diff master..experimental   # Можно сравнивать «головы» веток
git diff experimental           # активную ветку с какой-либо
git blame README     # построчную информацию о файле в последнем коммите
git annotate README  # построчную информацию о файле в последнем коммите
git blame -L 2,+3 README # информацию по трем строкам, начиная со второй

# ПОИСК В ПРОЕКТЕ
git grep            # поиск слов по проекту
git grep tst        # Ищет слова tst в проекте
git grep -с tst     # Подсчитывает число упоминаний tst
git grep tst v1     # Ищет в старой версии проекта
git grep -e 'first' --and -e 'another' # где упомин. 'first' и 'another'

# ИСТОРИЯ КОММИТОВ
git log                   # перечисляет коммиты
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
    --pretty="..." # определяет формат вывода.
    %h  # укороченный хэш коммита
    %ad # дата коммита
    %s  # комментарий
    %d  # дополнения коммита («головы» веток или теги)
    %an # имя автора
    --graph      # отображает дерево коммитов в виде ASCII-графика
    --date=short # сохраняет формат даты коротким и симпатичным
git log --pretty=oneline  # каждый из коммитов по строчке, состоящей из хэша
git log febc32...f292     # читает лог с коммита по коммит
git log README            # историю отдельного файла
git log — README          # если версия git не совсем свежая
git log -p                # подробную информацию о каждом патче
git log -p -2             # разницу, внесенную в каждый коммит (2 записи)
git log --stat            # Статистика изменения файлов
git log --summary         # инф. по созданиям, переименованиям и правам доступа
git log -S <string>       # там, где добавляется или удаляется эта строка
git log -- path/to/file   # те коммиты, в которых были изменения этих файлов
git log --pretty=oneline --graph  # добавится небольшой граф в формате ASCII
git log --pretty=full/fuller      # полная информация о коммитах
    oneline               # каждый коммит в одну строку
    short, full и fuller  # делают вывод приблизительно в том же формате
    format:"%h - %an, %ar : %s"
        %h  - Сокращенный хеш коммита
        %an - Имя автора
        %ar - Относительная дата автора
        %s  - Содержание
    ...
git log --since=2.weeks   # за последние две недели
        --author          # фильтровать по автору коммита
        --grep            # искать по ключевым словам

# УДАЛИТЬ ИЗ ИНДЕКСА:
git rm <file>           # удалить файл из раб. каталога и индекса
git rm -r dir1          # удалить каталог ...
git rm --cached <file>  # удалить из индекса, но оставит в раб. каталоге
git rm -f <file>        # игнорировать предупреждения при удалении
git rm log/\*.log       # можно использ. шаблоны

# ОТКАТ ИЗМЕНЕНИЙ
git reset <file|dir>       # сбросить индекс для файла (по умол. для всех)
git checkout <file>        # отмена изменений ДО ИНДЕКСАЦИИ
git checkout -f            # отбросит незакомит. изм-я, оставаясь в тек. ветке
git checkout <hash>        # перекл. на коммит (Состояние отделённой HEAD: не указ. на ветку)
git checkout <hash> <file> # откатить файл до указ-го комита
git checkout HEAD <file>   # отменить незакомич. изменения в файле
git checkout HEAD~2 <file> # файл к состоянию на два коммита назад
git restore <file>         # откат непроиндексированных изменений
git restore --stage <file> # откат проиндексированных изменений
git revert HEAD --no-edit  # отмен. коммит до предыд. версии (--no-edit  - без редактора)
git revert config-modify-tag # Отменяет коммит, помеченный тегом
git revert cgsjd2h         # Отменяет коммит, используя его хэш
git revert cgsjd2h -m 1    # отмена коммита слияния, нужно указ. хэш и номер одного из родителей коммита
# (Состояние проекта не должно отличаться от состояния, зафиксир. последним коммитом)
# 'Мягкий' сброс:
git reset --soft HEAD^  # 'мягкий' сброс на последний коммит
# 'Жёсткий' сброс (и удал. из ветки, но останутся в репо):
git reset --hard v1     # сброс до тега (в истории можно увидеть только с парам. --all)
git reset --hard HEAD   # передумали разрешать конфликт
git reset --hard HEAD~3 # три последних коммита будут удалены!!!
# ВРЕМЕННЫЙ ОТКАТ
git stash      # сброс незафикс. измен-й, которые можно вернуть через 'git stash pop'
git stash pop  # вернуть сброшен. измен-я (можно перемещ. незаком. изм-я в другую ветку)

# РАБОТА С ВЕТКАМИ
git branch -v              # инф-я о локальн. ветках
git branch -a              # список лок. и удаленных веток
git branch -f main <hash|branch> # ПЕРЕМЕСТ. ветку main на коммит или др. ветку
git branch <new_branch>    # СОЗДАТЬ новую ветку, но не переключает на неё
git branch -d <new_branch> # УДАЛИТЬ ветку "new_branch"
git branch -D <new_branch> # УДАЛИТЬ без смердживания
git branch -m <new_name>   # ПЕРЕИМЕНОВАТЬ текущую
git branch --contains v1.2 # Показ. ветки, среди предков которых есть опред. коммит
git checkout master        # перекл. на ветку master
git checkout -- master     # '--' указывает путь на папку master
git checkout -b dev        # создать ветку и перекл. на неё (branch + checout)
git checkout -B dev <hash> # ПЕРЕМЕСТ. ветку и переключ. на неё (branch -f + checout)
git checkout -f dev        # перекл. без спроса (отбросит незакомит. изм-я)
git checkout -m dev        # перед перекл-ем попробует залить изменения в текущую ветку
git merge <new_branch>     # смерджить ветку "new_branch" с текущей
git merge-base master <new_branch> # Показ. коммит ответвления ветки new_branch от master

# Схоже с checkout, но checkout работает только с указателем HEAD, 
# а reset перемещает указатель HEAD и указатель текущей ветки
git reset    (аналогично: reset --mixed <хеш коммита>)
git reset --hard

# ОДНОВРЕМЕННАЯ РАБОТА С НЕСКОЛЬКИМИ ВЕТКАМИ
git worktree add path/ remote/master  # добавление ветки в отдельную директорию
git worktree list                     # просмотр всех директорий с ветками
git worktree move old-path/ new-path/ # перести в другое место
git worktree remove path/             # удалить

# ПОДМОДУЛИ
git submodule add https://... # добавить в тек. проект другой репозиторий (подмодуль)
# После этого необходимо добавить и зафиксировать новый файл .gitmodules
git submodule update --init --recursive # иниц-ть и обнов. подмодули после клонирования
# (clone + submodule) иниц. и обнов. подмодули после клонир.:
    git clone --recursive https://... 
git submodule update --recursive        # точное состояние всех подмодулей
git submodule foreach git pull          # состояние последнего коммита всех подмодулей
# Обновить репозиторий:
    git add submodule_directory
    git commit
git submodule update --remote submodule_directory # сост-е послед. коммита конкретн. подмод
git mv /path/to/module new/path/to/module         # перемещение подмодуля
# удаление подмоуля:
    git submodule deinit the_submodule      # удалить описание подмодуля
    git rm the_submodule                    # удалить каталог

# ОТНОСИТЕЛЬНАЯ АДРЕСАЦИЯ
git diff master^  # можно обратиться прямо к предку последнего коммита ветки master
git diff HEAD^2   # адресоваться по нескольким предкам коммитов слияния
git diff master^^ # Что привнес «дедушка» нынешнего коммита
git diff master~2 # Что привнес «дедушка» нынешнего коммита
git diff master~3^~2  # Обозначения можно объединять, чтобы добраться до нужного коммита

# ТЕГИ
# 2 вида:
    1) аннотированные # полноценная ветка
    2) легковесные    # указатель с именем
# Теги отправляются на сервер только явно:
    git push origin v1
    git push --tags       # отправить все теги
git tag       # показ. теги
git tag -l    # перечисл. теги
git tag v1    # создать легковесный тег "v1"
git tag -a R2020.4 -m "Realise 2020.4" # создать аннотированный тег
git tag stable-2 f292ef5    # пометить опред. коммит
git tag -d stable-2         # Удаляет тег
git tag -f stable-1.1       # Создаёт/заменяет тэг для последнего коммита
git tag -a stable           # Создаёт обычный тэг для последнего коммита + комментарий
git tag -a stable -m "production version" # Созд. тэг, сразу указав комментарий
git tag v1.0-dev            # Установка начала новой версии на текущий коммит
# Получение номера версии для последующие коммитов
    git describe --tags
    v1.0-dev-3-g387f83f # v1.0-dev — имя тега; 3 — кол-во коммитов после этого тега; 387f83f — короткий хэш текущего коммита
    

# СЕРВЕРНЫЕ КОМАНДЫ
# Команда создания вспомогательных файлов для dumb-сервера в $GIT_DIR/info и 
# $GIT_OBJECT_DIRECTORY/info каталогах, чтобы помочь клиентам узнать, 
# какие ссылки и пакеты есть на сервере:
git update-server-info
git count-objects # Проверяет сколько объектов будет потеряно и объём освобождаемого места при перепаковке репозитория
git gc            # Переупаковывает локальный репозиторий

# TODO: РАЗОБРАТЬ
$ git  опции    команда    аргументы
# Сначала рассмотрим опции, они влияют на работу всей утилиты:
    • -C - использовать указанную папку репозитория вместо текущей папки;
    • -c параметр=значение - использовать указанное значение параметра конфигурации;
    • -p - прокручивать весь вывод с помощью less;
    • add - добавить файл или папку в репозиторий git;
    • am - применить все патчи из email;
    • archive - создать архив файлов;
    • bisect - использовать бинарный поиск для поиска нужного коммита;
    • branch - управление ветками проекта;
    • bundle - перемещение объектов и ссылок в архиве;
    • checkout - переключение между ветками;
    • cherry-pick - внести изменения в уже существующие коммиты;
    • clean - удалить все неотслеживаемые файлы и папки проекта;
    • clone - создать копию удаленного репозитория в папку;
    • commit - сохранить изменения в репозиторий;
    • diff - посмотреть изменения между коммитами;
    • fetch - скачать удаленный репозиторий;
    • init - создать репозиторий;
    • merge - объединить две ветви;
    • pull - интегрировать удаленный репозиторий с локальным;
    • push - отправить изменения в удаленный репозиторий;
    • tag - управление тегами;
    • worktree - управление деревнями разработки.