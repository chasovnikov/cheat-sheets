
/*
IndexedDB – это встроенная база данных (на стороне клиента), более мощная, чем localStorage.

Хранилище ключей/значений: доступны несколько типов ключей, а значения 
    могут быть (почти) любыми.
Поддерживает транзакции для надёжности.
Поддерживает запросы в диапазоне ключей и индексы.
Позволяет хранить больше данных, чем localStorage.

IndexedDB предназначена для оффлайн приложений, можно совмещать с ServiceWorkers 
    и другими технологиями.
 */

// Открыть базу данных
let openRequest = indexedDB.open(name, version);
/*  name    – название базы данных, строка
    version – версия базы данных, положительное целое число, по умолчанию 1

После этого вызова необходимо назначить обработчик событий для объекта openRequest:
success:        база данных готова к работе, готов «объект базы данных» openRequest.result, 
    его следует использовать для дальнейших вызовов.
error:          не удалось открыть базу данных.
upgradeneeded:  база открыта, но её схема устарела или ещё не существует

IndexedDB имеет встроенный механизм «версионирования схемы», 
    который отсутствует в серверных базах данных.
*/

let openRequest = indexedDB.open("store", 2);
// проверить существование указанной версии базы данных, обновить по мере необходимости:
openRequest.onupgradeneeded = function() {
  // версия существующей базы данных меньше 2 (или база данных не существует)
  let db = openRequest.result;
  switch(db.version) { // существующая (старая) версия базы данных
    case 0:
      // версия 0 означает, что на клиенте нет базы данных
      // выполнить инициализацию
    case 1:
      // на клиенте версия базы данных 1
      // обновить
  }
};

// Удалить базу данных:
let deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror отслеживает результат



/// Проблема параллельного обновления

// Если есть две вкладки, на которых открыт наш сайт, но в одной открыто соединение 
// с базой версии 1, а другая пытается обновить версию базы в обработчике upgradeneeded
let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = function() { /*...*/ };
openRequest.onerror = function() { /*...*/ };

openRequest.onsuccess = function() {
  let db = openRequest.result;

//   узнать о попытке параллельного обновления
  db.onversionchange = function() {
    db.close();
    alert("База данных устарела, пожалуста, перезагрузите страницу.")
  };

  // ...база данных доступна как объект db...
};

// При парал.обновл-ии новое соединение будет заблокировано с событием blocked
openRequest.onblocked = function() {
  // есть другое соединение к той же базе
  // и оно не было закрыто после срабатывания на нём db.onversionchange
};



/// Хранилище объектов

// Мы можем хранить почти любое значение, в том числе сложные объекты.
// IndexedDB использует стандартный алгоритм сериализации для клонирования и 
// хранения объекта. Это как JSON.stringify, но более мощный, способный хранить 
// гораздо больше типов данных.
// Объекта, который нельзя сохранить: объект с циклическими ссылками.
// Ключ должен быть одним из следующих типов: number, date, string, binary или array.

// Создать хранилище
// db.createObjectStore(name[, keyOptions]);
/*name – это название хранилища, например "books" для книг,
keyOptions      – это необязательный объект с одним или двумя свойствами:
keyPath         – путь к свойству объекта, которое IndexedDB будет использовать 
    в качестве ключа, например id.
autoIncrement   – если true, то ключ будет формироваться автоматически для новых объектов, 
    как постоянно увеличивающееся число.

Хранилище объектов можно создавать/изменять только при обновлении версии базы данных 
    в обработчике upgradeneeded.
*/

// Два способа обновления версии базы:
// 1. реализовать функции обновления по версиям: с 1 на 2, с 2 на 3 и т.д.
// 2. используя db.objectStoreNames:
let openRequest = indexedDB.open("db", 2);
// создаём хранилище объектов для books, если ешё не существует
openRequest.onupgradeneeded = function() {
  let db = openRequest.result;
  if (!db.objectStoreNames.contains('books')) {     // если хранилище "books" не существует
    db.createObjectStore('books', {keyPath: 'id'}); // создаем хранилище
  }
};

// Удалить хранилище объектов
db.deleteObjectStore('books');



/// Транзакции
// Транзакция – это группа операций, которые должны быть или все выполнены, 
//      или все не выполнены (всё или ничего).

// Все операции с данными в IndexedDB могут быть сделаны только внутри транзакций.

// Для начала транзакции:
// db.transaction(store[, type]);
/*
store       – это название (или массив названий) хранилища
type        – тип транзакции, один из:
    readonly        – только чтение, по умолчанию.
    readwrite       – только чтение и запись данных («блокируют» хранилище).
    versionchange   - могут делать любые операции, но мы не можем создать их вручную.

IndexedDB автоматически создаёт транзакцию типа versionchange, когда открывает базу данных, 
    для обработчика updateneeded
*/
let transaction = db.transaction("books", "readwrite");     // Создать транзакцию 

// получить хранилище объектов для работы с ним
let books = transaction.objectStore("books");   // Получить хранилище объектов

let book = {
  id: 'js',
  price: 10,
  created: new Date()
};

let request = books.add(book);      // Выполнить запрос на добавление элемента в хранилище

request.onsuccess = function() {    // Обработать результат запроса
  console.log("Книга добавлена в хранилище", request.result);
};

request.onerror = function() {
  console.log("Ошибка", request.error);
};


// Хранилища объектов поддерживают два метода для добавления значений:
// put(value, [key])    Добавляет значение value в хранилище.
// add(value, [key]) Добавляет значение, если не было такого ключа, 
//      иначе будет сгенерирована ошибка с названием "ConstraintError".
/*Аналогично открытию базы, мы отправляем запрос: books.add(book) и 
    после ожидаем события success/error.
request.result для add является ключом нового объекта.
Ошибка находится в request.error (если есть).*/


/// Автоматическая фиксация транзакций

// Когда все запросы завершены и очередь микрозадач пуста, тогда транзакция 
//      завершится автоматически.
// Такое автозавершение транзакций имеет важный побочный эффект. 
//      Мы не можем вставить асинхронную операцию, такую как fetch или setTimeout 
//      в середину транзакции.
// Решение этой проблемы:
//      Сначала сделаем fetch, подготовим данные, если нужно, затем создадим 
//      транзакцию и выполним все запросы к базе данных.

// Чтобы поймать момент успешного выполнения, мы можем повесить обработчик на 
//      событие transaction.oncomplete:
let transaction = db.transaction("books", "readwrite");
// ...выполнить операции...
transaction.oncomplete = function() {
  console.log("Транзакция выполнена");
};

// Чтобы вручную отменить транзакцию, выполните:
transaction.abort();        // сгенерирует событие transaction.onabort.



/// Обработка ошибок

// При ошибке в запросе соответствующая транзакция отменяется полностью, 
//      включая изменения, сделанные другими её запросами.
// Продолжить транзакцию: в обработчике request.onerror вызвать event.preventDefault().

let transaction = db.transaction("books", "readwrite");
let book = { id: 'js', price: 10 };
let request = transaction.objectStore("books").add(book);

request.onerror = function(event) {
  // ConstraintError возникает при попытке добавить объект с ключом, который уже существует
  if (request.error.name == "ConstraintError") {
    console.log("Книга с таким id уже существует"); // обрабатываем ошибку
    event.preventDefault(); // предотвращаем отмену транзакции
    // ...можно попробовать использовать другой ключ...
  } else {
    // неизвестная ошибка
    // транзакция будет отменена
  }
};

transaction.onabort = function() {
  console.log("Ошибка", transaction.error);
};



/// Делегирование событий

// обработчики onerror/onsuccess нужны не всегда: можно использовать делегирование событий.
// События IndexedDB всплывают: запрос → транзакция → база данных.

/*Мы можем остановить всплытие, используя event.stopPropagation() в request.onerror.*/
request.onerror = function(event) {
  if (request.error.name == "ConstraintError") {
    console.log("Книга с таким id уже существует"); // обрабатываем ошибку
    event.preventDefault(); // предотвращаем отмену транзакции
    event.stopPropagation(); // предотвращаем всплытие ошибки
  } else {
    // ничего не делаем
    // транзакция будет отменена
    // мы можем обработать ошибку в transaction.onabort
  }
};



/// Поиск по ключам

/*Есть два основных вида поиска в хранилище объектов:
1. По ключу или по диапазону ключей: book.id в хранилище «books»
2. По полям объекта:                 book.price

1. Методы поиска поддерживают либо точные ключи, либо так называемые 
«запросы с диапазоном» – IDBKeyRange объекты, которые задают «диапазон ключей».

Диапазоны создаются:
IDBKeyRange.lowerBound(lower, [open]) означает: >lower (или ≥lower, если open это true)
IDBKeyRange.upperBound(upper, [open]) означает: <upper (или ≤upper, если open это true)
IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen]) означает: 
    между lower и upper, включительно, если соответствующий open равен true.
IDBKeyRange.only(key) – диапазон, который состоит только из одного ключа key
*/ 


// ...

