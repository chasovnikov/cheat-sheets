
/**============= Тип данных Number ================
 * К нему относятся и Infinity, -Infinity и NaN.
 */

let billion = 1e9;  // 1 миллиард
let ms = 1e-6;      // 0.000001

// Шестнадцатеричные числа
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)

let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
/**
 * Есть только 3 системы счисления с такой поддержкой (0x, 0b, 0o). 
 * Для других систем счисления используют parseInt()
 */

/**
 * num.toString(base) возвращает строковое представление числа num в системе счисления base
 * base может варьироваться от 2 до 36 (по умолчанию 10)
 */
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

// ".." - Если нам надо вызвать метод непосредственно на числе
alert( 123456..toString(36) ); // 2n9c

/**
 * Округление
 * Math.floor
 *      Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
 * Math.ceil
 *      Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
 * Math.round
 *      Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
 * Math.trunc (не поддерживается в Internet Explorer)
 *      Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
 * toFixed(n) 
 *      округляет число до n знаков после запятой и ВОЗРАЩАЕТ СТРОКУ
 */
let num = 12.34;
alert( num.toFixed(5) ); // "12.34000"


/**
 * Неточные вычисления
 */
alert( 0.1 + 0.2 == 0.3 ); // false
alert( 0.1.toFixed(20) ); // 0.10000000000000000555

// Решение проблемы: округление
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"

// метод умножения/деления уменьшает погрешность, но полностью её не решает
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001


/**
 * Infinity (и -Infinity) — особенное численное значение, 
 *      которое ведёт себя в точности как математическая бесконечность ∞.
 * 
 * NaN представляет ошибку.
 * Глобальное свойство NaN является значением, представляющим не-число (Not-A-Number).
 * Эти числовые значения принадлежат типу number
 */
NaN === NaN;        // false
Number.NaN === NaN; // false
isNaN(NaN);         // true
isNaN(Number.NaN);  // true

function valueIsNaN(v) { return v !== v; }
valueIsNaN(1);          // false
valueIsNaN(NaN);        // true
valueIsNaN(Number.NaN); // true

/**
 * Разница между функцией isNaN() и методом Number.isNaN(): 
 *      Number.isNaN() проверяет текущее значение.
 */
isNaN('hello world');        // true
Number.isNaN('hello world'); // false

/**
 * isFinite(value) 
 *      преобразует аргумент в число и возвращает true, 
 *      если оно является обычным числом, т.е. не NaN/Infinity/-Infinity
 */
alert( isFinite("15") );        // true
alert( isFinite("str") );       // false, потому что специальное значение: NaN
alert( isFinite(Infinity) );    // false, потому что специальное значение: Infinity

/**
 * Object.is
 * сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:
 * 1. Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
 * 2. Значения 0 и -0 разные: Object.is(0, -0) === false, 
 *          это редко используется, но технически эти значения разные.
 */

/**
 * Для явного преобразования к числу можно использовать + или Number(). 
 * Если строка не является в точности числом, то результат будет NaN:
 */
alert( +"100px" ); // NaN

/**
 * parseInt и parseFloat.
 * Они «читают» число из строки.
 * Если в процессе чтения возникает ошибка, они возвращают полученное 
 * до ошибки число. Функция parseInt возвращает целое число, 
 * а parseFloat возвращает число с плавающей точкой
 */
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('12.3') ); // 12, вернётся только целая часть
alert( parseFloat('12.3.4') ); // 12.3, произойдёт остановка чтения на второй точке
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения

// Второй аргумент parseInt(str, radix) - система счисления
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает
alert( parseInt('2n9c', 36) ); // 123456


/**
 * Math.random()
 *      Возвращает псевдослучайное число в диапазоне 
 *      от 0 (включительно) до 1 (но не включая 1)
 * Math.max(a, b, c...) / Math.min(a, b, c...)
 *      Возвращает наибольшее/наименьшее число из перечисленных аргументов.
 * Math.pow(n, power)
 *      Возвращает число n, возведённое в степень power
 */
