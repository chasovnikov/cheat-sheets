
/**
 * Set - «множество» УНИКАЛЬНЫХ значений без ключей
 * Перебор в том же порядке, в каком и добавление
 * 
 */
let set = new Set( ["апельсин", "яблоко", "банан"] );

// добавить элемент и вернуть объект Set
set.add( {fruit: "яблоко"} ) // не добавится - уже есть
   .add( {fruit: "яблоко"} ) // не добавится
   .add( {fruit: "груша"} );

// удалить значение и вернуть "true", если оно присутствовало
alert( set.delete("яблоко") ); 

// проверить наличие значения
alert( set.has('яблоко') );

// очистить всё множество
set.clear();

// показать количество элементов
alert( set.size );

// Перебирается с помощью for..of и forEach
for (let value of set) {
    alert(value);
}

set.forEach( (value, valueAgain, set) => {
  alert(value);
} );

/**
 * Set имеет те же встроенные методы, что и Map:
 * set.values(),
 * set.keys() – присутствует для обратной совместимости с Map,
 * set.entries() – возвращает перебираемый объект для пар вида [значение, значение], 
 *      присутствует для обратной совместимости с Map.
 */


/**===============================
 *          WeakSet
 * аналогична Set, но мы можем добавлять в WeakSet только объекты
 * Объект присутствует в множестве только до тех пор, пока доступен где-то ещё
 * Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
 * 
 */