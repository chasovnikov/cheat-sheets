// Программы на JavaScript могут быть вставлены в любое место HTML-документа с помощью тега <script>.

// <!DOCTYPE HTML>
// <html>
// <body>
//   <p>Перед скриптом...</p>

//   <script>
//     alert( 'Привет, мир!' );
//   </script>

//   <p>...После скрипта.</p>
// </body>
// </html>

// Можно подключить JS из файла:
// <script src="/path/to/script.js"></script>
// Но в одном теге <script> нельзя использовать одновременно атрибут src и код внутри.



/**
 * В старых браузерах консоль не учитывает такой use strict, 
 * там можно «оборачивать» код в функцию, вот так:
 */
 (function() {
    'use strict';
  
    // ...ваш код...
  })()  // создание и сразу вызов функции (блок с локальной видимостью)


// Так можно
let user = 'John', age = 25, message = 'Hello';

// Имена переменных могут начинаться с "$", "_" и букв, но далее могут идти еще и цифры.


/**================== Типы данных ===================================
 *  String, Boolean, Number, BigInt, Symbol, Object, null, undefined
 */

/**============= Тип данных Number ================
 * К нему относятся и Infinity, -Infinity и NaN.
 */

/**============ Тип данных BigInt============================
 *  Пример обозначения: 3214n
 * В JavaScript тип «number» не может содержать числа больше, чем ((2**53)-1).
 */
 const bigint = 1234567890123456789012345678901234567890n;
 const sameBigint = BigInt("1234567890123456789012345678901234567890"); 
 const bigintFromNumber = BigInt(10); // то же самое, что и 10n

// BigInt можно использовать как обычные числа
 alert(1n + 2n); // 3

// В математических операциях мы не можем смешивать bigint и обычные числа:
 alert(1n + 2); // Error: Cannot mix BigInt and other types

let bigint = 1n;
// К BigInt числам нельзя применить унарный оператор +
alert( +bigint ); // SyntaxError: Unexpected identifier


/**============ Тип данных String =============
 * Строки неизменяемы
 * 3 вида кавычек
 */
let str = "Привет"; // Применяются в JSON
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str} 
    и могут занимать более одной строки`;

let name = "Ilya";
// выражение - число 1
alert( `hello ${1}` ); // hello 1
// выражение - строка "name"
alert( `hello ${"name"}` ); // hello name
// выражение - переменная, вставим её в строку
alert( `hello ${name}` ); // hello Ilya


/**
 * Тип данных NULL
 * В JavaScript null не является «ссылкой на несуществующий объект» 
 * или «нулевым указателем», как в некоторых других языках.
 * Это просто специальное значение, которое представляет собой «ничего», 
 * «пусто» или «значение неизвестно».
 */

/**
 * Тип данных undefined
 * Означает, что «значение не было присвоено».
 * Если переменная объявлена, но ей не присвоено никакого значения, 
 * то её значением будет undefined
 * Обычно null используется для присвоения переменной «пустого» 
 * или «неизвестного» значения, а undefined – для проверок, 
 * была ли переменная назначена
 */

//  возвращает тип аргумента
typeof val;
typeof (val);
typeof Math // "object"  (1)
typeof null // "object"  (2)
typeof alert // "function"  (3)

// Окно с вводом
let age = prompt('Сколько тебе лет?', 100); // 100 - по умолчанию
// Окно с сообщением
alert(`Тебе ${age} лет!`); // Тебе 100 лет!

// Окно "Да/Нет"
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK
/**
 * Все эти методы являются модальными: останавливают выполнение скриптов
 *  и не позволяют пользователю взаимодействовать с остальной частью страницы
 *  до тех пор, пока окно не будет закрыто
 */


/**
 * Преобразование типов
 * 
 * Явные преобразования:
 */
String(123);
Number("123z");
Boolean('sds');

/**
 * Приведение к числу:
 *      undefined    -	NaN
 *      null         -	0
 *      true / false -	1 / 0
 *      string	    - Пробельные символы по краям обрезаются. Далее, 
 *          если остаётся пустая строка, то получаем 0, иначе из непустой 
 *          строки «считывается» число. При ошибке результат NaN.
 */
// Неявное преобразование к числу с помощью унарного оператора
let str = "121fg";
let num = +str; // NaN

/** 
 * Приведение к Boolean:
 * Приводятся к false:
 *      0,
 *      -0,
 *      "",
 *      null,
 *      undefined,
 *      NaN
 * Все остальные значения становятся true.
 *      "0", -  true (не пустая строка)
 *      " "  -  true (не пустая строка)
 */

// Примеры:
"" + 1 + 0 // "10"
"" - 1 + 0 // -1
true + false // 1
6 / "3" // 2
"2" * "3" // 6
4 + 5 + "px" // "9px"
"$" + 4 + 5 // "$45"
"4" - 2 // 2
"4px" - 2 // NaN
7 / 0 // Infinity
"  -9  " + 5 // "  -9  5"
"  -9  " - 5 // -14
undefined + 1 // NaN 
" \t \n" - 2 // -2 


/**
 * Так можно:
 */
let c = 3 - (a = b + 1);
a = b = c = 2 + 2;
n += 5; // n = n + 5
n *= 7; // n = n * 7
counter++; // постфиксная форма инкремента
++counter; // префиксная форма инкремента
counter--; // постфиксная форма декремента
--counter; // префиксная форма декремента


/**
 * Побитовые операторы работают с 32-разрядными целыми числами 
 * (при необходимости приводят к ним), 
 * на уровне их внутреннего двоичного представления
 * AND(и) ( & )
 * OR(или) ( | )
 * XOR(побитовое исключающее или) ( ^ )
 * NOT(не) ( ~ )
 * LEFT SHIFT(левый сдвиг) ( << )
 * RIGHT SHIFT(правый сдвиг) ( >> )
 * ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
 */

/**
 * Оператор "запятая"
 * Позволяет вычислять несколько выражений.
 * Каждое выражение выполняется, но возвращается результат только последнего.
 */
 let a = (1 + 2, 3 + 4);
 alert( a ); // 7 (результат вычисления 3 + 4)
 // три операции в одной строке с помощью оператора "запятая"
for (a = 1, b = 3, c = a * b; a < 10; a++) { }


/**
 * Сравнение с null и undefined
 */
null === undefined; // false
null == undefined; // true
alert( null > 0 );  // false
alert( null == 0 ); // false (null равен нестрого только undefined)
alert( null >= 0 ); // true (сравнения преобразуют null в 0)

alert( undefined > 0 ); // false
alert( undefined < 0 ); // false
alert( undefined == 0 ); // false

/**
 * Оператор объединения с null "??"
 * Возвращает первый аргумент, если он не null/undefined, иначе второй
 */
let a = b ?? "b - пусто";
let a = b ?? с ?? d ?? "пусто";


/**
 * Функции
 * 
 * Function Declaration можно использовать во всем скрипте 
 * (или блоке кода, если функция объявлена в блоке).
 * В строгом режиме, когда Function Declaration находится в блоке {...}, 
 * функция доступна везде внутри блока. Но не снаружи него.
 */
function sayHi() {
  alert( "Привет" );
}

/**
 * Function Expression создаётся, когда выполнение доходит до него, 
 * и затем уже может использоваться.
 */
let sayHi = function() {
  alert( "Привет" );
};  // ";" обязательна, т.к. здесь - выражение


// Функции-«колбэки» - функции, передаваемые в аргументы другой функции
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);

// "Стрелочные" функции
let sum = (a, b) => a + b;
let sum = a => a + b;
let sum = (a, b) => {
  return a + b; // return обязателен с {}
};



/**
 * Сборка мусора по принципу достижимости: удаляются объекты, 
 *    которые стали недостижимы.
 * «Достижимые» значения – это те, которые доступны или используются. 
 *    Они гарантированно находятся в памяти.
 * Не могут быть удалены:
 *    Локальные переменные и параметры текущей функции.
 *    Переменные и параметры других функций в текущей цепочке вложенных вызовов.
 *    Глобальные переменные.
 *    (некоторые другие внутренние значения)
 *    Любое другое значение считается достижимым, 
 *        если оно доступно по ссылке или по цепочке ссылок
 */


/**
 * Методы у примитивов
 * Каждый примитив имеет свой собственный «объект-обёртку», 
 * которые называются: String, Number, Boolean и Symbol.
 * Некоторые языки, такие как Java, позволяют явное создание 
 * «объектов-обёрток» для примитивов при помощи такого синтаксиса 
 * как new Number(1) или new Boolean(false).
 * В JavaScript, это тоже возможно по историческим причинам, 
 * но очень не рекомендуется
 */
 alert( typeof 0 ); // "число"
 alert( typeof new Number(0) ); // "object"!
/**
 * С другой стороны, использование функций String/Number/Boolean 
 * без оператора new – вполне разумно и полезно. Они превращают значение 
 * в соответствующий примитивный тип
 */



/**
 * Глобальный объект хранит переменные, которые должны быть доступны 
 *      в любом месте программы.
 * Универсальное имя – globalThis.Но чаще на него ссылаются по-старому, 
 *      используя имя, характерное для данного окружения, 
 *      такое как window (браузер) и global (Node.js)
 */