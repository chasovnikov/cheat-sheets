
 /**============ Тип данных String =============
 * Строки неизменяемы
 * Строки в JavaScript кодируются в UTF-16
 * Можно перебрать строку посимвольно, используя for..of
 * 3 вида кавычек:
 */
let str = "Двойные кавычки";       // Применяются в JSON
let str2 = 'Одинарные кавычки тоже подойдут';
let phrase = `Обратные кавычки позволяют встраивать переменные ${str} 
и могут занимать более одной строки`;
let longString = "Двойные и одинарные кавычки \
могут быть многострочными \
с помощью экранирования обратным слэшем." 

// механика обратных кавычек
let userName = "Ilya";
alert( `hello ${userName}` );   // hello Ilya
alert( `hello ${1}` );      // hello 1
alert( `hello ${"name"}` ); // hello name


let str = `Hello`;
// получаем первый символ
str[0]            // H
str.charAt(0)     // H
str[1000]         // undefined    !!!
str.charAt(1000)  // ''           !!! Отличие charAt() от []
// получаем последний символ
str[str.length - 1] // o


'Interface'.toUpperCase(); // INTERFACE
'Interface'.toLowerCase(); // interface

'Widget'.indexOf('id', 3); // -1, индекс подстроки, начиная поиск с позиции 3
    ~'Widget'.indexOf('id', 3); // 0, то же, что -(-1+1)
'Widget'.lastIndexOf('e', 3); //, поиск от конца к началу, начиная с индекса 3

"Midget".includes("id", 3); // false, поиск подстроки с позиции 3
"Widget".startsWith("Wid"); // true, поиск начала строки
"Widget".endsWith("get"); // true, поиск конца строки

let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2); // [Вася, Петя]

let str = "stringify";
str.slice(3, 5);         // "in", строка от 3 до 5
str.substring(2, 6);     // "ring"
    str.substring(6, 2); // "ring"
str.substr(3, 2);        // "in", строка от 3 длинной 2 (устаревший метод)
/**
 * Формально у метода substr есть небольшой недостаток: 
 * он описан не в собственно спецификации JavaScript, 
 * а в приложении к ней — Annex B
 */


// Вернуть код символа в UTF-16
"z".codePointAt(0); // 122
"Z".codePointAt(0); // 90
// "Z" < "z"  (90 < 122) - сравнение идет по коду

// Создаёт символ по его коду
String.fromCodePoint(90); // Z
// используя \u с шестнадцатеричным кодом символа:
String.fromCodePoint('\u005a'); // Z

/**
 * Правильное сравнение.
 * Сравнение в соответствии с ПРАВИЛАМИ языка (а не по коду):
 * -1, если str < str2.
 * 1, если str > str2.
 * 0, если str === str2.
 */
 str.localeCompare(str2);
'Österreich'.localeCompare('Zealand'); // -1

/**
 * String.fromCodePoint и str.codePointAt 
 * правильно работают с СУРРОГАТНЫМИ ПАРАМИ в отличие от
 * похожим методов String.fromCharCode и str.charCodeAt
 */

/**
 * Диакритические знаки и нормализация
 */
// после S добавить специальный символ «точка сверху» (код \u0307)
alert( 'S\u0307' ); // Ṡ
alert( 'S\u0307\u0323' ); // Ṩ

let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху
alert( `s1: ${s1}, s2: ${s2}` );
alert( s1 == s2 ); // false, хотя на вид символы одинаковы (?!)
/**
 * Для решения этой проблемы есть алгоритм «юникодной нормализации», 
 * приводящий каждую строку к единому «нормальному» виду.
 * Его реализует метод str.normalize().
 */
 alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

 
/**
 * String(thing)
 * new String(thing)
 * @param {any} thing Всё, что может быть преобразовано в строку
 * 
 * Свойства:
 * String.prototype
 *      Позволяет добавлять свойства к объекту String.
 * 
 * 
 * Статические методы:
 * 
 * String.fromCharCode(num1 [, ...[, numN]])
 *      Создает строку по единицам кода UTF-16.
 * 
 * String.fromCodePoint(num1 [, ...[, numN)
 *      То же что и String.fromCharCode, но может вернуть один символ, 
 *      который на самом деле имеет длину 2, а не 1
 * 
 * String.raw(callSite, ...substitutions)
 * String.raw`templateString`
 *      Возвращает строку, созданную из сырой шаблонной строки.
 * 
 * 
 * Методы, унаследованные из Function:
 *      apply, call, toSource, toString
 * 
 * 
 * Динамические методы:
 * 
 *      ДОСТУП К СИМВОЛАМ:
 * 
 * .at(index) 
 *      Возвращает символ (ровно одну кодовую единицу UTF-16) по указанному индексу. 
 *      Принимает отрицательные целые числа, которые отсчитываются от последнего строкового символа.
 * 
 * .charAt(index)
 *      Возвращает символ (ровно одну кодовую единицу UTF-16) по указанному индексу.
 * 
 * .charCodeAt(index)
 *      Возвращает число, которое является значением кодовой единицы UTF-16 по заданному индексу.
 *      
 * 
 *      ИЗМЕНЕНИЕ РЕГИСТРА:
 * 
 * .toLowerCase()
 *      Возвращает значение вызывающей строки, преобразованное в нижний регистр.
 * 
 * .toUpperCase()
 *      Возвращает значение вызывающей строки, преобразованное в верхний регистр.
 * 
 * .toLocaleLowerCase( [locale, ...locales])
 *      Символы в строке преобразуются в нижний регистр с учетом текущего языкового стандарта.
 *      Для большинства языков будет возвращено то же значение, что и toLowerCase ().
 * 
 * .toLocaleUpperCase( [locale, ...locales])
 *      Символы в строке преобразуются в верхний регистр с учетом текущего языкового стандарта.
 *      Для большинства языков будет возвращено то же значение, что и toUpperCase ().
 * 
 *  
 *      ПОИСК ПОДСТРОКИ:
 *  
 * .indexOf(searchValue [, fromIndex])
 *      Возвращает индекс первого вхождения searchValue или -1, если не найден.
 * 
 * .lastIndexOf(searchValue [, fromIndex])
 *      Возвращает индекс последнего вхождения searchValue или -1, если не найден.
 * 
 * .includes(searchString [, position])
 *      Определяет, содержит ли вызывающая строка searchString.
 * 
 * .startsWith(searchString [, length])
 *      Определяет, начинается ли вызывающая строка с символов строки searchString.
 * 
 * .endsWith(searchString [, length])
 *      Определяет, заканчивается ли строка символами строки searchString.
 * 
 * 
 *      ПОЛУЧЕНИЕ ПОДСТРОКИ:
 * 
 * .slice(beginIndex[, endIndex])
 *      Извлекает часть строки и возвращает новую строку.
 * 
 * .substring(indexStart [, indexEnd])
 *      Возвращает новую строку, содержащую символы вызывающей строки из (или между) указанного индекса (или индексов).
 * 
 * 
 *      СРАВНЕНИЕ СТРОК:
 * 
 * .codePointAt(pos)
 *      Возвращает неотрицательное целое число Number, которое является значением кодовой точки 
 *      кодовой точки в кодировке UTF-16, начиная с указанной позиции.
 * 
 * .localeCompare(compareString [, locales [, options]])
 *      Возвращает число, указывающее, находится ли ссылочная строка compareString до, после или эквивалентна данной строке в порядке сортировки.
 * 
 * 
 *      РАБОТА С РЕГУЛЯРНЫМИ ВЫРАЖЕНИЯМИ:
 * 
 * .match(regexp)
 *      Используется для сопоставления регулярного выражения регулярного выражения со строкой.
 * 
 * .matchAll(regexp)
 *      Возвращает итератор всех совпадений регулярного выражения.
 * 
 * .replace(searchFor, replaceWith)
 *      Используется для замены вхождений searchFor с помощью replaceWith. searchFor может быть строкой или регулярным выражением, а replaceWith может быть строкой или функцией.
 * 
 * .replaceAll(searchFor, replaceWith)
 *      Используется для замены всех вхождений searchFor с помощью replaceWith. searchFor может быть строкой или регулярным выражением, а replaceWith может быть строкой или функцией.
 * 
 * .search(regexp)
 *      Найдите совпадение между регулярным выражением regexp и вызывающей строкой.
 *  
 * 
 * 
 * .toString()
 *      Возвращает строку, представляющую указанный объект. Переопределяет метод Object.prototype.toString ().
 *  
 * .concat(str [, ...strN ])
 *      Объединяет текст двух (или более) строк и возвращает новую строку.
 *  
 * .normalize([form])
 *      Возвращает форму нормализации Unicode вызывающего строкового значения.
 * 
 * .padEnd(targetLength [, padString])
 *      Дополняет текущую строку с конца заданной строкой и возвращает новую строку длины targetLength.
 * 
 * .padStart(targetLength [, padString])
 *      Дополняет текущую строку с начала заданной строкой и возвращает новую строку длины targetLength.
 * 
 * .repeat(count)
 *      Возвращает строку, состоящую из элементов объекта, повторяющихся количество раз.
 * 
 * .split([sep [, limit] ])
 *      Возвращает массив строк, заполненный путем разделения вызывающей строки на вхождения подстроки sep.
 *  
 * .trim()
 *      Обрезает пробелы в начале и в конце строки. Часть стандарта ECMAScript 5.
 * 
 * .trimStart()
 *      Обрезает пробелы в начале строки.
 * 
 * .trimEnd()
 *      Обрезает пробелы в конце строки.
 * 
 * .valueOf()
 *      Возвращает примитивное значение указанного объекта. Переопределяет метод Object.prototype.valueOf ().
 * 
 * .@@iterator()
 *      Возвращает новый объект итератора, который выполняет итерацию по кодовым точкам значения String, возвращая каждую кодовую точку как значение String.
 */