
/**
 * Объект - неупорядоченная коллекция свойств
 * Хранятся и копируются «по ссылке»
 * Имена свойств - строки или значения Symbol
 * Являются динамическими, т.к. свойства обычно можно добавлять и удалять, 
 *      но они могут использоваться для эмуляции статических объектов
 * 
 * В дополнение к имени и значению каждое свойство имеет три атрибута свойства:
    • writable (допускает запись) указывает, можно ли устанавливать
        значение свойства;
    • enumerable (допускает перечисление) указывает, возвращается
        ли имя свойства в цикле for/in ;
    • configurable (допускает конфигурирование) указывает, можно
        ли удалять свойство и изменять его атрибуты.
 * Объект, объявленный через const, может быть изменён.
 * Cвойства упорядочены особым образом: свойства с целочисленными ключами 
 *      сортируются по возрастанию, остальные располагаются в порядке создания.
 * Два объекта равны только в том случае, если это один и тот же объект.
 */

// Три способа создания объекта
const obj = {};             // объектный литерал
const obj = new Object();
const obj = Object.create();

let age = '20';
const obj = {
    age,                 // age: age  (краткая запись)
    "likes birds": true, // имя свойства из нескольких слов должно быть в кавычках
};
/**
 * user.likes birds = true   // не работает
 */
user["likes birds"] = true;  // так работает


// Вычисляемые свойства
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5   // bag.appleComputers = 5
};


// Имя свойства может совпадать с зарезервированными словами
let obj = {
    for: 1,
    let: 2,
    return: 3,
  };


// in - Проверка наличия свойства
let obj = {
    test: undefined,
};
alert( obj.test );      // undefined
alert( "test" in obj ); // true, свойство существует!


// Свойства перебираются через for..in
for (prop in object) {
    alert( object[prop] );
  }


// Удаление свойства:
delete obj.prop;


/**
 * Object.assign(dest, [src1, src2, src3...])
 * Копирует в объект dest свойства всех исходных объектов src1, ..., srcN
 */
let user = { name: "Иван" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "Иван", canView: true, canEdit: true }

// Клонирование объекта user
let user = {age: 30};
let clone = Object.assign({}, user);

/**
 * Глубокое клонирование - вложенное копирование
 * Object.assign() - не подходит
 * Подойдёт:
 *  _.cloneDeep(obj) из JavaScript-библиотеки lodash
 */


/**
 * Методы объекта
 */
 let user = {
  name: "Джон",
  hi() { alert(this.name); }
};

// разделим получение метода объекта и его вызов в разных строках
let hi = user.hi;
hi(); // Ошибка, потому что значением this является undefined

/**
 * Проблема «несуществующего свойства».
 * Опциональная цепочка "?." останавливает вычисление и возвращает undefined, 
 *    если часть перед "?." имеет значение undefined или null
 * Имеет три формы:
 * obj?.prop – возвращает obj.prop, если существует obj, и 
 *    undefined в противном случае.
 * obj?.[prop] – возвращает obj[prop], если существует obj, и 
 *    undefined в противном случае.
 * obj.method?.() – вызывает obj.method(), если существует obj.method, 
 *    в противном случае возвращает undefined.
 */
let user = {}; // пользователь без адреса
alert( user?.address?.street ); // undefined (без ошибки)

// "?." работает с методами
let user1 = {
  admin() {
    alert("Я администратор");
  }
}
let user2 = {};
user1.admin?.(); // Я администратор
user2.admin?.();


delete user?.name; // Удалить user.name, если пользователь существует

/**
 * Преобразование к примитивам
 * Существуют 3 типа преобразований (хинтов):
 * "string" (для alert и других операций, которым нужна строка),
 * "number" - (для математических операций)
 * "default" - когда оператор «не уверен», какой тип ожидать
 * На практике все встроенные объекты, исключая Date,
 * реализуют "default" преобразования тем же способом, что и "number"
 * В процессе преобразования движок JavaScript пытается найти и вызвать 
 * три следующих метода объекта:
 * obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive 
 *    (системный символ), если такой метод существует, и передаёт ему хинт.
 * Иначе, если хинт равен "string"
 *    пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.
 * В случае, если хинт равен "number" или "default"
 *    пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.
 */


// Функция копирования объекта
 function copy(o) {
  var copy = Object.create(Object.getPrototypeOf(o));
  var propNames = Object.getOwnPropertyNames(o);

  propNames.forEach(function(name) {
    var desc = Object.getOwnPropertyDescriptor(o, name);
    Object.defineProperty(copy, name, desc);
  });

  return copy;
}


/** 
 * Object.defineProperty(obj, prop, descriptor) 
 *      Определяет новое или изменяет существующее свойство непосредственно на объекте, 
 *      возвращая этот объект
 * 
 * Обычное добавление свойств через присваивание создаёт свойства, которые можно 
 * увидеть через перечисление свойств (с помощью цикла for...in или метода Object.keys), 
 * чьи значения могут быть изменены и которые могут быть удалены. 
 * Этот же метод позволяет настроить эти дополнительные детали свойства.
 */
const data = {};
Object.defineProperties(data, 'add', {
  configurable: false,     // нельзя изменять и удалять
  enumerable: false,       // нельзя увидеть через перечисление свойств
  value(key, value) {
    data[key] = value;
    return data;
  }
});



/**
 * Объект через замыкания и стрелочную ф-ию.
 * Не нужно писать constructor, т.к. свойства задаются в аргументах.
 */
const point = (x, y) => {
    const p = {};

    p.move = (dx, dy) => {
        x += dx;
        y += dy;
    };

    p.toString = () => `[${x}, ${y}]`;

    return p;
};

const p1 = point(10, 20);
p1.move(-5, 10);


/**
 * Object.length
 *      Имеет значение 1.
 * 
 * Object.assign()
 *      Создаёт новый объект путём копирования значений всех собственных 
 *      перечислимых свойств из одного или более исходных объектов в целевой объект.
 * 
 * Object.create()
 *      Создаёт новый объект с указанными объектом прототипа и свойствами.
 * 
 * Object.keys()
 *      Возвращает массив, содержащий имена всех собственных перечислимых
 *      свойств переданного объекта.
 * 
 * Object.defineProperty()
 *      Добавляет к объекту именованное свойство, описываемое переданным дескриптором.
 * 
 * Object.defineProperties()
 *      Добавляет к объекту именованные свойства, описываемые переданными дескрипторами.
 * 
 * Object.freeze()
 *      Замораживает объект: другой код не сможет удалить или изменить никакое свойство.
 * 
 * Object.isFrozen()
 *      Определяет, был ли объект заморожен.
 * 
 * Object.getOwnPropertyDescriptor()
 *      Возвращает дескриптор свойства для именованного свойства объекта.
 * 
 * Object.getOwnPropertyNames()
 *      Возвращает массив, содержащий имена всех переданных объекту собственных 
 *      перечисляемых и неперечисляемых свойств.
 * 
 * Object.getOwnPropertySymbols()
 *      Возвращает массив всех символьных свойств, найденных непосредственно в 
 *      переданном объекте.
 * 
 * Object.getPrototypeOf()
 *      Возвращает прототип указанного объекта.
 * 
 * Object.setPrototypeOf()
 *      Устанавливает прототип (т.е. внутреннее свойство [[Prototype]])
 * 
 * Object.is()
 *      Определяет, являются ли два значения различимыми
 * 
 * Object.isExtensible()
 *      Определяет, разрешено ли расширение объекта.
 * 
 * Object.preventExtensions()
 *      Предотвращает любое расширение объекта.
 * 
 * Object.seal()
 *      Предотвращает удаление свойств объекта другим кодом.
 * 
 * Object.isSealed()
 *      Определяет, является ли объект запечатанным (sealed).
 * 
 * Object.observe()
 *      Асинхронно наблюдает за изменениями в объекте.
 */