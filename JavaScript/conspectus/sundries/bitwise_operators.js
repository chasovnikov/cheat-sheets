
/**
 * Побитовые операторы интерпретируют операнды как последовательность из 32 битов.
 * 
 * Их двоичное представление называется «32-битное целое со знаком, 
 *      старшим битом слева и дополнением до двойки».
 * 
 * Старший бит слева – это порядок записи цифр (от большего разряда к меньшему). 
 *      Если больший разряд отсутствует, то соответствующий бит равен нулю.
 * 
 * Дополнение до двойки – это название способа поддержки отрицательных чисел.
 *      Нули заменяются на единицы, единицы – на нули и к числу прибавляется 1.
 * Принцип дополнения до двойки делит все двоичные представления на два множества: 
 *      если крайний-левый бит равен 0 – число положительное, 
 *      если 1 – число отрицательное. Поэтому этот бит называется знаковым битом.
 * 
Побитовое И (AND)	
    a & b	
        Результат 1, если a и b равны 1.

Побитовое ИЛИ (OR)	
    a | b	
        Результат 1, если a или b равны 1.

Побитовое исключающее ИЛИ (XOR)	
    a ^ b	
        Результат 1, если a или b равны 1, но не оба.

Побитовое НЕ (NOT)	
    ~a	
        Результат 1, если a равен 0.
~n == -(n+1)
 */
alert( ~3 );    // -4
alert( ~-1 );   // 0

/**
Левый сдвиг	
    a << b	
        Сдвигает a на b битов влево, добавляя справа нули.
9                                    (по осн.10)
  = 00000000000000000000000000001001 (по осн.2)
9 << 2                               (по осн.10)
  = 00000000000000000000000000100100 (по осн.2)
  = 36                               (по осн.10)
Левый сдвиг почти равен умножению на 2:
alert( 3 << 1 );        // 6
alert( 3 << 2 );        // 12, умножение на 2 два раза
alert( 3 << 3 );        // 24, умножение на 2 три раза
Верхний порог такого «умножения» ограничен 32-мя битами.


Правый сдвиг, переносящий знак	
    a >> b	
        Сдвигает a на b битов вправо, отбрасывая сдвигаемые биты.
Правый сдвиг почти равен целочисленному делению на 2:
alert( 100 >> 1 );      // 50
alert( 100 >> 2 );      // 25, деление на 2 два раза
alert( 100 >> 3 );      // 12, деление на 2 три раза, целая часть от результата


Правый сдвиг с заполнением нулями	
    a >>> b	
        Сдвигает a на b битов вправо, отбрасывая сдвигаемые биты и добавляя нули слева
Результат всегда положителен.
 */

/**
 * Применение побитовых операторов.
 * 
 * Упаковка нескольких битововых значений («флагов») в одно значение. 
 *      Это экономит память и позволяет проверять наличие комбинации флагов 
 *      одним оператором &.
 * 
 * Например, обозначение ролей пользователя на сайте.

Пользователь	Просмотр статей	Изменение статей	Просмотр товаров	Изменение товаров	Управление правами	В 10-ной системе
Гость	        1	            0	                1	                0	                0	                = 20
Редактор	    1	            1	                1	                1	                0	                = 30
Админ	        1	            1	                1	                1	                1	                = 31

Итого, например, доступ гостя 10100 = 20.
 */
var ACCESS_ADMIN = 1;            // 00001
var ACCESS_GOODS_EDIT = 2;       // 00010
var ACCESS_GOODS_VIEW = 4;       // 00100
var ACCESS_ARTICLE_EDIT = 8;     // 01000
var ACCESS_ARTICLE_VIEW = 16;    // 10000

// Нужная комбинация доступов
var guest = ACCESS_ARTICLE_VIEW | ACCESS_GOODS_VIEW;           // 10100
var editor = guest | ACCESS_ARTICLE_EDIT | ACCESS_GOODS_EDIT;  // 11110
var admin = editor | ACCESS_ADMIN;                             // 11111

// Ненулевой результат будет означать, что доступ есть:
alert(editor & ACCESS_ADMIN);            // 0, доступа нет
alert(editor & ACCESS_ARTICLE_EDIT);     // 8, доступ есть

// Можно проверить один из нескольких доступов.
var check = ACCESS_GOODS_VIEW | ACCESS_GOODS_EDIT;      // 6, 00110
alert( admin & check ); // не 0, значит есть доступ к просмотру ИЛИ изменению

/**
 * Используют в функциях, чтобы одним параметром передать несколько «флагов».
 * Побитовые операторы в JavaScript работают только с 32-битными числами, а значит, 
 *      к примеру, 33 доступа уже в число не упакуешь.
 * Найти пользователей с правами на изменение товаров или администраторов.
 */
findUsers(ACCESS_GOODS_EDIT | ACCESS_ADMIN);


/**
 * Округление
 * 
 * Так как битовые операции отбрасывают десятичную часть, то их можно использовать 
 *      для округления.
 * 
 * Например, двойное НЕ (~):
alert( ~~12.345 );      // 12

 * Подойдёт и Исключающее ИЛИ (^) с нулём:
alert( 12.345 ^ 0 );    // 12
 * Последнее даже более удобно, поскольку отлично читается:
alert(12.3 * 14.5 ^ 0); // (=178) "12.3 умножить на 14.5 и округлить"
 */