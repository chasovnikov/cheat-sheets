

// Пересечение множеств (элементы, содержащиеся в обоих массивах)
let intersection = arrA.filter(x => arrB.includes(x));

// Разность (arrA - arrB)
let difference = arrA.filter(x => !arrB.includes(x));

// Симметричная разность (arrA - arrB) + (arrB - arrA)
let difference = arrA.filter( x => !arrB.includes(x) )
    .concat( arrB.filter( x => !arrA.includes(x) ) );

// Объединение с дублированными элементами
let union = [...arrA, ...arrB];
// Объединение с уникальными элементами
let union = [...new Set([...arrA, ...arrB])];


// Последний индекс + 1
['K', 'L', 'M'].length                      // 3

// Каждый больше 4
[5, 6, 7, 8].every(el => el > 4)            // true

// Один из них больше 4
[-4, -2, 0, 2].some(el => el > 1)           // true

// Новый массив с элементами, выполнающими условие
[4, -2, 1, -5, 6].filter(el => el > 3)      // [4, 6]

// Функция для каждого элемента
['K', 'L', 'M', 'N'].forEach(el => console.log(el))

// Соединить
['K', 'L', 'M'].concat(['N', 'O'])          // ['K', 'L', 'M', 'N', 'O']

// Объединить в строку по разделителю
['K', 'L', 'M'].join('_')                   // 'K_L_M'

// Сортировать (как строки)
[1, -2, 15, 2, 0, 8].sort();                // [ -2, 0, 1, 15, 2, 8 ]
// Сортировать (как числа)
[1, -2, 15, 2, 0, 8].sort((a, b) => a - b);  // [ -2, 0, 1, 2, 8, 15 ]
// Сортировать как числа в обратном порядке
[1, -2, 15, 2, 0, 8].sort((a, b) => b - a);  // [ 15, 8, 2, 1, 0, -2 ]
// принимает массив объектов со свойством age и сортирует их по нему
arrUsers.sort( (objUser1, objUser2)  => objUser1.age - objUser2.age );
// перемешивает элементы массива (не все возможные варианты имеют одинаковую вероятность)
array.sort( () => Math.random() - 0.5 );

// Перевернуть
['K', 'L', 'M'].reverse()                   // ['M', 'L', 'K']

// Копию части массива
['K', 'L', 'M'].slice(1, 2)                 // ['L', 'M']
// Копия
['K', 'L', 'M'].slice()                     // ['K', 'L', 'M']

// Удалить один элемент, начиная от индекса 2. Вставить '5' и 'F'
['I', 'love', 'web'].splice(2, 1, '5', 'F') // новый:['web']; старый:[ "I", "love", "5", "F" ]

// Найти индекс первого попавшегося элемента
['K', 'L', 'O', 'L', 'M'].indexOf('L')      // 1

// Найти индекс последнего попавшегося эл-та
['K', 'L', 'O', 'L', 'M'].lastIndexOf('L')  // 3

// Новый массив с каждым преобразованным по ф-ии эл-ом
[4, 5, 6].map(el => el * 2)                 // [8, 10, 12]
// Массив имён из массива объектов
const names = users.map(user => user.name);
// Массив из преобразованных объектов
const newArr = arrUsers.map(objUser => ( {fullName: `${objUser.name} ${objUser.surname}`} ));
// Альтернатива map
let arr = Array.from(range, num => num * num);
// разбивает строку на массив её элементов (адекватно работает с суррогатными парами)
let chars = Array.from(str);

// Удалить и вернуть последний
[4, 5, 6].pop()                             // 6; массив станет [4, 5]

// Добавить в конец и вернуть новую длину
[4, 5, 6].push(7, 8)                        // 5; массив станет [4, 5, 6, 7, 8]

// Удалить и вернуть первый
[4, 5, 6].shift()                           // 4; массив станет [5, 6]

// Добавить в начало и вернуть новую длину
[4, 5, 6].unshift(7, 8)                     // 5; массив станет [7, 8, 4, 5, 6]

// Уменьшить до единственного значения (слева направо)
[2, 3, 4].reduce((a, b) => a + b)           // 9
// Вернуть сумму age из объектов в массиве
const sum = users.reduce( (accum, user) => accum + user.age, 0 )
// Уменьшить до единственного значения (справа на лево)
[2, 3, 4].reduceRight((a, b) => a + b)      // 9


// вернёт массив уникальных, не повторяющихся значений массива arr
const unique = Array.from( new Set(arr) );


// склеить в строку элементы псевдомассива arguments
[].join.call(arguments)