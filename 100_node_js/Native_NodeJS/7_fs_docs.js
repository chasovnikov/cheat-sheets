import * as fs from 'fs'; // API колбэков и синхрон.
import * as fsPromises from 'fs/promises'; // промисы

// Флаги файловой системы (доступны везде, где параметр flag принимает строку)
// 'a':     открыть файл для добавления. Если файл не существует, он создается.
// 'ax':    как 'a', но не работает, если путь существует.
// 'a+':    открыть файл для чтения и добавления. Если файл не существует, он создается.
// 'ax+':   аналогично «a +», но не работает, если путь существует.
// 'as':    открыть файл для добавления в синхронном режиме. Если файл не существует, он создается.
// 'as+':   открыть файл для чтения и добавления в синхронном режиме. Если файл не существует, он создается.
// 'r':     открыть файл для чтения. Исключение возникает, если файл не существует.
// 'r+':    открыть файл для чтения и записи. Исключение возникает, если файл не существует.
// 'rs+':   открыть файл для чтения и записи в синхронном режиме. Указывает операционной системе обходить кеш локальной файловой системы.

// Три вида использования:
// через колбэки (самые быстрые)
// через промисы (самые читабельные)
// синхронно

// Callback example (async)
fs.unlink('/tmp/hello', err => {
    if (err) throw err;
    console.log('successfully deleted /tmp/hello');
});

// Promise example (async)
// При промисах необходимо соблюдать осторожность при выполнении нескольких одновременных
//      изменений одного и того же файла, иначе может произойти повреждение данных
try {
    await fsPromises.unlink('/tmp/hello');
    console.log('successfully deleted /tmp/hello');
} catch (error) {
    console.error('there was an error:', error.message);
}

// Synchronous example
try {
    fs.unlinkSync('/tmp/hello');
    console.log('successfully deleted /tmp/hello');
} catch (err) {
    // handle the error
}

// -------------------------------------------------------------------------------------------
// -------------  Class: FileHandle (для Promises API)
// "Это объект-оболочка для числового ФАЙЛОВОГО ДЕСКРИПТОРА
// Файловый дескриптор — это неотрицательное число, которое является идентиф-ом потока ввода-вывода.
//      Дескриптор может быть связан с файлом, каталогом, сокетом.
// Все объекты <FileHandle> являются объектами <EventEmitter>
// Всегда явно закрывайте <FileHandle>
Event: 'close'; // <FileHandle> закрывается и больше не может использоваться
filehandle.appendFile(data, options); // Псевдоним filehandle.writeFile()
filehandle.chmod(mode); // Изменяет права доступа к файлу
filehandle.chown(uid, gid); // Меняет владельца файла
filehandle.close(); // Закр. дескр-р файла после ожидания заверш-я любой ожидающей операции над дескриптором
filehandle.createReadStream(options); //
filehandle.createWriteStream(options); //
filehandle.datasync(); // Переводит операции ввода-вывода в очереди, связанные с файлом, в состояние завершения синхронизированного ввода-вывода
filehandle.fd; // Числовой дескриптор файла, управляемый объектом <FileHandle>
filehandle.read(buffer, offset, length, position); // Читает данные из файла и сохраняет их в заданном буфере
filehandle.read(options); // Читает данные из файла и сохраняет их в заданном буфере
filehandle.readFile(options); // Асинхронно читает все содержимое файла
filehandle.readv(buffers, position); // Чтение из файла и запись в массив <ArrayBufferView> s
filehandle.stat(options); // Возвращает: <Promise> Соответствует <fs.Stats> для файла
filehandle.sync(); // Запросите, чтобы все данные для дескриптора открытого файла были сброшены на запоминающее устройство
filehandle.truncate(len); // Обрезает файл
filehandle.utimes(atime, mtime); // Измените временные метки файловой системы объекта, на который ссылается <FileHandle>, затем разрешает обещание без аргументов в случае успеха
filehandle.write(buffer, offset, length, position); // Записать буфер в файл
filehandle.write(string, position, encoding); // Записать строку в файл
filehandle.writeFile(data, options); // Асинхронно записывает данные в файл, заменяя файл, если он уже существует
filehandle.writev(buffers, position); // Запишите в файл массив <ArrayBufferView>

// Promises API (почти аналогичные методы есть для Callback API, Synchronous API)

fsPromises.access(path, mode); // Проверяет права пользователя для файла или каталога
fsPromises.appendFile(path, data, options); // Асинхронно добавлять данные в файл, создавая файл, если он еще не существует
fsPromises.chmod(path, mode); // Изменяет права доступа к файлу
fsPromises.chown(path, uid, gid); // Меняет владельца файла
fsPromises.copyFile(src, dest, mode); // Асинхронно копирует src в dest. По умолчанию, адрес назначения перезаписывается, если он уже существует
fsPromises.cp(src, dest, options); // Асинхронно копирует всю структуру каталогов от src до dest, включая подкаталоги и файлы
fsPromises.lchmod(path, mode); // Изменяет права доступа к символьной ссылке
fsPromises.lchown(path, uid, gid); // Меняет владельца символьной ссылки
fsPromises.lutimes(path, atime, mtime); // Изменяет время доступа и модификации файла так же, как fsPromises.utimes (), с той разницей, что если путь ссылается на символическую ссылку, то ссылка не разыменовывается
fsPromises.link(existingPath, newPath); // Создает новую ссылку из существующего пути на новый путь
fsPromises.lstat(path, options); // Эквивалентен fsPromises.stat (), если путь не относится к символической ссылк
fsPromises.mkdir(path, options); // Асинхронно создает каталог
fsPromises.mkdtemp(prefix, options); // Создает уникальный временный каталог
fsPromises.open(path, flags, mode); // Открывает <FileHandle>
fsPromises.opendir(path, options); // Асинхронно открыть каталог для итеративного сканирования
fsPromises.readdir(path, options); // Читает содержимое каталога
fsPromises.readFile(path, options); // Асинхронно читает все содержимое файла
fsPromises.readlink(path, options); // Читает содержимое символической ссылки
fsPromises.realpath(path, options); // Определяет фактическое местоположение пути, используя ту же семантику, что и функция fs.realpath.native ()
fsPromises.rename(oldPath, newPath); // Переименовывает oldPath в newPath
fsPromises.rmdir(path, options); // Удаляет каталог
fsPromises.rm(path, options); // Удаляет файлы и каталоги
fsPromises.stat(path, options); // Возвращает: <Promise> Соответствует объекту <fs.Stats> для заданного пути
fsPromises.symlink(target, path, type); // Создает символическую ссылку
fsPromises.truncate(path, len); // Обрезает (укорачивает или увеличивает длину) содержимого по пути до len байтов
fsPromises.unlink(path); // Если путь относится к символической ссылке, то ссылка удаляется, не затрагивая файл или каталог, на который ссылается эта ссылка. Если путь относится к пути к файлу, который не является символической ссылкой, файл удаляется
fsPromises.utimes(path, atime, mtime); // Измените временные метки файловой системы объекта, на который имеется ссылка по пути
fsPromises.watch(filename, options); // следит за изменениями в файле или каталоге
fsPromises.writeFile(file, data, options); // Асинхронно записывает данные в файл, заменяя файл, если он уже существует

// ------------- Common Objects (Общие объекты используются всеми вариантами API файловой системы)

// Class: fs.Dir
// Класс, представляющий поток каталога
dir.close();
dir.close(callback);
dir.closeSync();
dir.path;
dir.read();
dir.read(callback);
dir.readSync();
dir[Symbol.asyncIterator]();

// Class: fs.Dirent
// Представление записи каталога, которое может быть файлом или подкаталогом в каталоге, полученное при чтении из <fs.Dir>
dirent.isBlockDevice();
dirent.isCharacterDevice();
dirent.isDirectory();
dirent.isFIFO();
dirent.isFile();
dirent.isSocket();
dirent.isSymbolicLink();
dirent.name;

// Class: fs.FSWatcher
Event: 'change';
Event: 'close';
Event: 'error';
watcher.close();
watcher.ref();
watcher.unref();

// Class: fs.StatWatcher
watcher.ref();
watcher.unref();

// Class: fs.ReadStream
Event: 'close';
Event: 'open';
Event: 'ready';
readStream.bytesRead;
readStream.path;
readStream.pending;

// Class: fs.ReadStream
// Экземпляры <fs.ReadStream> создаются и возвращаются с помощью функции fs.createReadStream ()
Event: 'close';
Event: 'open';
Event: 'ready';
readStream.bytesRead;
readStream.path;
readStream.pending;

// Class: fs.WriteStream
Event: 'close';
Event: 'open';
Event: 'ready';
writeStream.bytesWritten;
writeStream.close([callback]);
writeStream.path;
writeStream.pending;

// Class: fs.Stats
// предоставляет информацию о файле
stats.isBlockDevice();
stats.isCharacterDevice();
stats.isDirectory();
stats.isFIFO();
stats.isFile();
stats.isSocket();
stats.isSymbolicLink();
stats.dev;
stats.ino;
stats.mode;
stats.nlink;
stats.uid;
stats.gid;
stats.rdev;
stats.size;
stats.blksize;
stats.blocks;
stats.atimeMs;
stats.mtimeMs;
stats.ctimeMs;
stats.birthtimeMs;
stats.atimeNs;
stats.mtimeNs;
stats.ctimeNs;
stats.birthtimeNs;
stats.atime;
stats.mtime;
stats.ctime;
stats.birthtime;

fs.constants;
// for use with fs.access():
// F_OK     Флаг, указывающий, что файл виден вызывающему процессу. Это полезно для определения того, существует ли файл, но ничего не говорит о разрешениях rwx. По умолчанию, если режим не указан.
// R_OK     Флаг, указывающий, что файл может быть прочитан вызывающим процессом.
// W_OK     Флаг, указывающий, что файл может быть записан вызывающим процессом.
// X_OK     Флаг, указывающий, что файл может быть выполнен вызывающим процессом. Это не влияет на Windows (будет вести себя как fs.constants.F_OK).

// for use with fs.copyFile():
// COPYFILE_EXCL    Если присутствует, операция копирования завершится ошибкой, если целевой путь уже существует.
// COPYFILE_FICLONE     Если присутствует, операция копирования будет пытаться создать рефссылку копирования при записи. Если базовая платформа не поддерживает копирование при записи, то используется резервный механизм копирования.
// COPYFILE_FICLONE_FORCE   Если присутствует, операция копирования попытается создать ссылку на копирование при записи. Если базовая платформа не поддерживает копирование при записи, операция завершится ошибкой.

// for use with fs.open():
// O_RDONLY     Флаг, указывающий на открытие файла только для чтения.
// O_WRONLY     Флаг, указывающий на открытие файла только для записи.
// O_RDWR       Флаг, указывающий на открытие файла для чтения-записи.
// O_CREAT      Флаг, указывающий на создание файла, если он еще не существует.
// O_EXCL       Флаг, указывающий, что открытие файла должно завершиться ошибкой, если установлен флаг O_CREAT и файл уже существует.
// O_NOCTTY     Флаг, указывающий, что если путь идентифицирует оконечное устройство, открытие пути не должно приводить к тому, что этот терминал становится управляющим терминалом для процесса (если процесс еще не имеет его).
// O_TRUNC      Флаг, указывающий, что если файл существует и является обычным файлом, и файл успешно открыт для доступа для записи, его длина должна быть сокращена до нуля.
// O_APPEND     Флаг, указывающий, что данные будут добавлены в конец файла.
// O_DIRECTORY  Флаг, указывающий, что открытие должно завершиться ошибкой, если путь не является каталогом.
// O_NOATIME    Флаг, указывающий, что доступ для чтения к файловой системе больше не будет приводить к обновлению временной информации, связанной с файлом. Этот флаг доступен только в операционных системах Linux.
// O_NOFOLLOW   Флаг, указывающий, что открытие должно завершиться ошибкой, если путь является символической ссылкой.
// O_SYNC       Флаг, указывающий, что файл открыт для синхронизированного ввода-вывода с операциями записи, ожидающими целостности файла.
// O_DSYNC      Флаг, указывающий, что файл открыт для синхронизированного ввода-вывода с операциями записи, ожидающими целостности данных.
// O_SYMLINK    Флаг, указывающий на открытие самой символической ссылки, а не ресурса, на который она указывает.
// O_DIRECT     Если установлено, будет сделана попытка минимизировать эффекты кэширования файлового ввода-вывода.
// O_NONBLOCK   Флаг, указывающий на открытие файла в неблокирующем режиме, когда это возможно.
// UV_FS_O_FILEMAP      Если установлено, отображение файла в памяти используется для доступа к файлу. Этот флаг доступен только в операционных системах Windows. В других операционных системах этот флаг игнорируется.

// для использования со свойством режима объекта <fs.Stats> для определения типа файла:
// S_IFMT       Битовая маска, используемая для извлечения кода типа файла.
// S_IFREG      Константа типа файла для обычного файла.
// S_IFDIR      Константа типа файла для каталога.
// S_IFCHR      Константа типа файла для символьного файла устройства.
// S_IFBLK      Константа типа файла для блочного файла устройства.
// S_IFIFO      Константа типа файла для FIFO / канала.
// S_IFLNK      Константа типа файла для символьной ссылки.
// S_IFSOCK     Константа типа файла для сокета.

// для использования со свойством режима объекта <fs.Stats> для определения прав доступа к файлу:
// S_IRWXU      Файловый режим, указывающий, что владелец может читать, записывать и исполнять.
// S_IRUSR      Файловый режим с указанием возможности чтения владельцем.
// S_IWUSR      Файловый режим, указывающий на возможность записи владельцем.
// S_IXUSR      Файловый режим с указанием исполняемого файла владельцем.
// S_IRWXG      Файловый режим, указывающий на чтение, запись и исполнение по группе.
// S_IRGRP      Файловый режим с указанием возможности чтения группой.
// S_IWGRP      Файловый режим, указывающий на возможность записи группой.
// S_IXGRP      Файловый режим с указанием исполняемых файлов по группе.
// S_IRWXO      Файловый режим, указывающий, что другие могут читать, записывать и исполнять.
// S_IROTH      Файловый режим с указанием возможности чтения другими.
// S_IWOTH      Файловый режим, указывающий на возможность записи другими пользователями.
// S_IXOTH      Файловый режим, указывающий на то, что другие исполняют.
