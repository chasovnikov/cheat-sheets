/*
Введение

Пакет - это дерево папок, описываемое файлом package.json. 
Пакет состоит из папки, содержащей файл package.json, и всех вложенных папок до следующей папки, 
содержащей другой файл package.json, или папки с именем node_modules.

На этой странице представлены рекомендации для авторов пакетов, пишущих файлы package.json, 
а также ссылки на поля package.json, определенные Node.js .

Определяющая модульная система#
Node.js будет рассматривать следующее как модули ES при передаче узлу в качестве начального 
ввода или при ссылках с помощью инструкций импорта в коде модуля ES:

Файлы, заканчивающиеся на .mjs.

Файлы, оканчивающиеся на .js, когда ближайший родительский файл пакета.json содержит поле 
верхнего уровня "тип" со значением "модуль".

Строки, передаваемые в качестве аргумента в --eval или передаваемые на узел через STDIN с 
флагом --input-type=модуль.

Node.js будет рассматривать как CommonJS все другие формы ввода, такие как файлы .js, где 
ближайший родительский файл package.json не содержит поля "тип" верхнего уровня 
или строкового ввода без флага --input-type. Такое поведение предназначено для 
сохранения обратной совместимости. Однако теперь, когда Node.js поддерживает 
как модули CommonJS, так и ES, поэтому лучше быть явным, когда это возможно. 

Node.js будет рассматривать следующее как CommonJS при передаче узлу в качестве 
начального ввода или при ссылках на инструкции импорта в коде модуля ES:

Файлы, заканчивающиеся на .cjs.

Файлы, оканчивающиеся на .js, когда ближайший родительский файл пакета.json содержит поле 
верхнего уровня "тип" со значением "commonjs".

Строки, передаваемые в качестве аргумента в --eval или --print, или передаваемые на узел 
через STDIN с флагом --input-type=commonjs.

Авторы пакетов должны включать поле "тип", даже в пакетах, где все источники являются CommonJS. 
Четкое указание типа пакета позволит в будущем защитить пакет в случае, если тип по умолчанию 
Node.js когда-либо меняется, и это также облегчит инструментам сборки и загрузчикам определение 
того, как следует интерпретировать файлы в пакете.

пакет.json и расширения файлов#
В пакете поле "тип" package.json определяет, как Node.js следует интерпретировать файлы .js. 
Если в файле package.json нет поля "тип", файлы .js рассматриваются как CommonJS.

Значение "типа" package.json для "модуля" сообщает Node.js интерпретировать файлы .js 
в этом пакете как использующие синтаксис модуля ES.

Поле "тип" применяется не только к начальным точкам входа (узлу my-app.js ), но также 
и к файлам, на которые ссылаются операторы импорта и выражения import().
*/

// my-app.js , рассматриваемый как модуль ES, потому что существует package.json
// файл в той же папке с надписью "тип": "модуль".

import './startup/init.js';
// // Загружается как модуль, так как ./запуск не содержит файла package.json,
// и поэтому наследует значение "тип" на один уровень выше.

import 'commonjs-package';
// Загружается как CommonJS с ./node_modules/commonjs-пакет/package.json
// отсутствует поле "тип" или содержит "тип": "commonjs".

import './node_modules/commonjs-package/index.js';
// Загружается как CommonJS с ./node_modules/commonjs-пакет/package.json
// отсутствует поле "тип" или содержит "тип": "commonjs".

Файлы, заканчивающиеся на .mjs, всегда загружаются как модули, независимо от 
ближайшего родительского пакета.json.

Файлы, заканчивающиеся на .cjs, всегда загружаются как CommonJS, независимо от 
ближайшего родительского пакета.json.

импорт './устаревший файл.cjs';
// Загружается как CommonJS, так как .cjs всегда загружается как CommonJS.

импорт "commonjs-пакет/src/индекс.mjs";
// Загружается как модуль ES, так как .mjs всегда загружается как модуль ES.
Расширения .mjs и .cjs можно использовать для смешивания типов в одном пакете:

В пакете "тип": "модуль", Node.js может быть дано указание интерпретировать 
конкретный файл как CommonJS, назвав его расширением .cjs (поскольку файлы .js и .mjs 
рассматриваются как модули ES в пакете "модуль").

В пакете "тип": "commonjs", Node.js может быть дано указание интерпретировать конкретный файл 
как модуль ES, назвав его расширением .mjs (поскольку файлы .js и .cjs рассматриваются 
как CommonJS в пакете "commonjs").

--флаг типа ввода#
Добавлено в: v12.0.0
Строки, передаваемые в качестве аргумента --eval (или -e) или передаваемые на узел через STDIN, 
рассматриваются как модули ES, если установлен флаг --input-type=модуль.

узел --тип ввода=модуль --оценка "импорт { sep } из "пути"; console.log(sep);"

echo "импорт { sep } из 'пути'; console.log(sep);" | узел --тип ввода=модуль
Для полноты картины есть также --input-type=commonjs, для явного ввода строки как CommonJS. 
Это поведение по умолчанию, если --тип ввода не указан.

Определение менеджера пакетов#
Стабильность: 1 - Экспериментальная
В то время как все Node.js ожидается, что проекты будут устанавливаться всеми менеджерами 
пакетов после публикации, их группам разработчиков часто требуется использовать один 
конкретный менеджер пакетов. Чтобы облегчить этот процесс, Node.js поставляется с инструментом 
под названием Corepack, который призван сделать все менеджеры пакетов прозрачно доступными 
в вашей среде - при условии, что у вас есть Node.js установлен.

По умолчанию Corepack не будет применять какой-либо конкретный менеджер пакетов и будет 
использовать общие "Последние известные хорошие" версии, связанные с каждым Node.js релиз, 
но вы можете улучшить этот опыт, установив поле "PackageManager" в файле package.json вашего проекта.

Точки входа в пакет#
В файле package.json пакета два поля могут определять точки входа для пакета: "основной" 
и "экспорт". Поле "основное" поддерживается во всех версиях Node.js , но его возможности 
ограничены: он определяет только основную точку входа пакета.

Поле "экспорт" предоставляет альтернативу "основной", где можно определить основную точку 
входа пакета, одновременно инкапсулируя пакет, предотвращая любые другие точки входа, 
кроме тех, которые определены в "экспорте". Эта инкапсуляция позволяет авторам модулей 
определять общедоступный интерфейс для своего пакета.

Если определены как "экспорт", так и "основной", поле "экспорт" имеет приоритет над "основным". 
"экспорт" не относится к модулям ES или CommonJS; "основной" переопределяется "экспортом", 
если он существует. Таким образом, "основной" не может использоваться в качестве запасного 
варианта для CommonJS, но его можно использовать в качестве запасного варианта для устаревших 
версий Node.js которые не поддерживают поле "экспорт".

Условный экспорт можно использовать в разделе "экспорт" для определения различных точек входа 
пакета для каждой среды, в том числе для указания того, ссылается ли пакет через запрос или 
через импорт. Для получения дополнительной информации о поддержке модулей CommonJS и ES в 
одном пакете, пожалуйста, обратитесь к разделу двойные пакеты модулей CommonJS/ES.

Предупреждение: Введение поля "экспорт" не позволяет потребителям пакета использовать любые 
точки входа, которые не определены, включая package.json (например, требовать 
('ваш-пакет/пакет.json'). Скорее всего, это будет кардинальное изменение.

Чтобы сделать внедрение "экспорта" непрерывным, убедитесь, что экспортирована каждая ранее 
поддерживаемая точка входа. Лучше всего явно указывать точки входа, чтобы публичный 
API пакета был четко определен. Например, проект, который ранее экспортировал main, 
библиотеку, функцию и файл package.json, может использовать следующий пакет.экспорт:

{
  "name": "my-mod",
  "exports": {
    ".": "./lib/index.js",
    "./lib": "./lib/index.js",
    "./lib/index": "./lib/index.js",
    "./lib/index.js": "./lib/index.js",
    "./feature": "./feature/index.js",
    "./feature/index.js": "./feature/index.js",
    "./package.json": "./package.json"
  }
}

В качестве альтернативы проект может экспортировать целые папки:
{
  "name": "my-mod",
  "exports": {
    ".": "./lib/index.js",
    "./lib": "./lib/index.js",
    "./lib/*": "./lib/*.js",
    "./feature": "./feature/index.js",
    "./feature/*": "./feature/*.js",
    "./package.json": "./package.json"
  }
}

В крайнем случае, инкапсуляцию пакета можно полностью отключить, создав экспорт для 
корневого каталога пакета "./*": "./*". Это открывает доступ к каждому файлу в пакете 
за счет отключения инкапсуляции и потенциальных преимуществ инструментария, которые 
это обеспечивает. В качестве загрузчика модуля ES в Node.js принудительно использует 
полный путь спецификатора, экспортируя корень вместо того, чтобы указывать явный ввод, 
менее выразительно, чем в любом из предыдущих примеров. Не только теряется инкапсуляция, 
но и потребители модулей не могут импортировать функцию из "my-mod /feature", поскольку 
им необходимо предоставить функцию импорта полного пути из 'my-mod/feature/index.js .

Экспорт основной точки входа#
Чтобы установить основную точку входа для пакета, рекомендуется определить как "экспорт", 
так и "основной" в файле package.json пакета:
{
  "main": "./main.js",
  "exports": "./main.js"
}

Когда определено поле "экспорт", все вложенные пути пакета инкапсулируются и больше не 
доступны импортерам. Например, требовать('pkg/subpath.js ') выдает ошибку 
ERR_PACKAGE_PATH_NOT_EXPORTED.

Эта инкапсуляция экспорта обеспечивает более надежные гарантии в отношении интерфейсов 
пакетов для инструментов и при обработке обновлений semver для пакета. Это не является 
надежной инкапсуляцией, поскольку прямое требование любого абсолютного подпутя пакета, 
такого как require('/path/to/node_modules/pkg/subpath.js ') все равно будет загружаться 
subpath.js .

Экспорт подпутей#
Добавлено в: v12.7.0
При использовании поля "экспорт" пользовательские подпути могут быть определены вместе с 
основной точкой входа, рассматривая основную точку входа как подпуть ".":
{
  "main": "./main.js",
  "exports": {
    ".": "./main.js",
    "./submodule": "./src/submodule.js"
  }
}
Теперь потребитель может импортировать только определенный подпуть в разделе "экспорт".:

импортировать подмодуль из "es-модуль-пакет/подмодуль";
// Нагрузки ./node_modules/es-module-package/src/submodule.js
В то время как другие подпути приведут к ошибке:

импортировать подмодуль из 'es-module-package/private-module.js ';
// Выдает ОШИБКУ_ПАКЕТ_ПУТЬ_НЕ_ЭКСПОРТИРОВАН


Импорт подпутей#
Добавлено в: v14.6.0, v12.19.0
В дополнение к полю "экспорт" можно определить внутренние карты импорта пакета, которые 
применяются только к спецификаторам импорта из самого пакета.

Записи в поле импорт всегда должны начинаться с #, чтобы убедиться, что они не являются 
неоднозначными по сравнению со спецификаторами пакетов.

Например, поле импорт может использоваться для получения преимуществ условного экспорта 
для внутренних модулей:
// package.json
{
  "imports": {
    "#dep": {
      "node": "dep-node-native",
      "default": "./dep-polyfill.js"
    }
  },
  "dependencies": {
    "dep-node-native": "^1.0.0"
  }
}
где импорт '#dep' не получает разрешение внешнего пакета dep-node-native (включая, в свою 
очередь, его экспорт), а вместо этого получает локальный файл ./dep-polyfill.js по сравнению 
с пакетом в других средах.

В отличие от поля "экспорт", поле "импорт" позволяет сопоставлять внешние пакеты.

Правила разрешения для поля импорт в остальном аналогичны полю экспорт.

Шаблоны подпутей#
Добавлено в: v14.13.0, v12.20.0
Для пакетов с небольшим количеством экспорта или импорта мы рекомендуем явно указывать каждую 
запись подпути экспорта. Но для пакетов с большим количеством подпутей это может привести к 
раздуванию файла package.json и проблемам с обслуживанием.

Для этих случаев использования вместо этого можно использовать шаблоны экспорта подпутей:
// ./node_modules/es-module-package/package.json
{
  "exports": {
    "./features/*": "./src/features/*.js"
  },
  "imports": {
    "#internal/*": "./src/internal/*.js"
  }
}
* карты отображают вложенные подпути, так как это только синтаксис замены строк.

Все экземпляры * с правой стороны будут заменены этим значением, в том числе, если оно 
содержит какие-либо разделители /.
import featureX from 'es-module-package/features/x';
// Loads ./node_modules/es-module-package/src/features/x.js

import featureY from 'es-module-package/features/y/y';
// Loads ./node_modules/es-module-package/src/features/y/y.js

import internalZ from '#internal/z';
// Loads ./node_modules/es-module-package/src/internal/z.js

Это прямая статическая замена без какой-либо специальной обработки расширений файлов. 
В предыдущем примере pkg/features/x.json будет преобразован в ./src/features/x.json.js в картографии.

Свойство экспорта быть статически перечислимым поддерживается шаблонами экспорта, поскольку 
отдельные экспорта для пакета могут быть определены путем обработки целевого шаблона правой 
стороны как ** глобуса по сравнению со списком файлов в пакете. Поскольку пути к 
node_modules запрещены в целях экспорта, это расширение зависит только от файлов самого пакета.

Чтобы исключить частные подпапки из шаблонов, можно использовать нулевые целевые значения:

// ./node_modules/es-модуль-пакет/пакет.json
{
  "экспорт": {
    "./функции/*": "./src/функции/*.js",
"./функции/частные-внутренние/*": ноль
  }
}
импорт внутренних функций из "es-модуль-пакет/функции/частные-внутренние/m";
// Выдает: ОШИБКА_ПАКЕТ_ПУТЬ_НЕ_ЭКСПОРТИРОВАН

импортируйте featureX из "es-модуль-пакет/функции/x";
// Нагрузки ./node_modules/es-module-package/src/features/x.js
Сопоставления папок с подпутями

До того, как были поддержаны шаблоны подпутей, для поддержки сопоставлений папок использовался 
завершающий суффикс "/":

{
  "экспорт": {
    "./особенности/": "./особенности/"
  }
}
Эта функция будет удалена в следующем выпуске.

Вместо этого используйте шаблоны прямых подпутей:

{
  "экспорт": {
    "./функции/*": "./функции/*.js"
  }
}
Преимущество шаблонов перед экспортом папок заключается в том, что потребители всегда 
могут импортировать пакеты без необходимости в расширениях файлов подпутей.

Экспортирует сахар#
Добавлено в: v12.11.0
Если экспорт "." является единственным экспортом, в поле "экспорт" указывается сахар для 
этого случая, являющийся прямым значением поля "экспорт".

Если экспорт "." содержит резервный массив или строковое значение, то в поле "экспорт" 
можно установить это значение напрямую.

{
  "экспорт": {
    ".": "./main.js "
  }
}
может быть написано:

{
  "экспорт": "./main.js "
}


Условный экспорт#
История
Условный экспорт предоставляет возможность сопоставления с различными путями в зависимости 
от определенных условий. Они поддерживаются как для импорта модулей CommonJS, так и для ES.

Например, пакет, который хочет обеспечить экспорт различных модулей ES для require() и импорта, 
может быть написан:

// пакет.json
{
  "главная": "./главная-требуется.cjs",
"экспорт": {
    "импорт": "./main-module.js ",
"требовать": "./main-требовать.cjs"
  },
"тип": "модуль"
}
Node.js реализует следующие условия:

"импорт" - соответствует, когда пакет загружается с помощью импорта или импорта() или с 
помощью любой операции импорта или разрешения верхнего уровня загрузчиком модуля ECMAScript. 
Применяется независимо от формата модуля целевого файла. Всегда взаимоисключающее с "требовать".
"требовать" - совпадает, когда пакет загружается с помощью require(). Указанный файл должен 
быть доступен для загрузки с помощью require(), хотя условие совпадает независимо от формата 
модуля целевого файла. Ожидаемые форматы включают CommonJS, JSON и собственные дополнения, 
но не модули ES, поскольку require() их не поддерживает. Всегда взаимоисключающий с "импортом".
"узел" - соответствует любому Node.js окружающая среда. Может быть файлом модуля CommonJS или ES. 
Это условие всегда должно быть после "импортировать" или "требовать".
"узлы-дополнения" - аналогично "узлу" и соответствует любому Node.js окружающая среда. 
Это условие может быть использовано для обеспечения точки входа, которая использует собственные 
дополнения C++, в отличие от точки входа, которая является более универсальной и не зависит 
от собственных дополнений. Это условие можно отключить с помощью флага --no-addons.
"по умолчанию" - общий запасной вариант, который всегда совпадает. Может быть файлом модуля 
CommonJS или ES. Это условие всегда должно быть последним.
В объекте "экспорт" порядок ключей имеет важное значение. Во время сопоставления условий более 
ранние записи имеют более высокий приоритет и имеют приоритет над более поздними записями. 
Общее правило состоит в том, что условия должны быть от наиболее специфичных до наименее 
специфичных в порядке объектов.

Использование условий "импорт" и "требовать" может привести к некоторым опасностям, которые 
более подробно объясняются в разделе "Пакеты модулей dual CommonJS/ES".

Условный экспорт также может быть расширен до подпутей экспорта, например:

{
  "главное": "./main.js ",
"экспорт": {
    ".": "./main.js ",
"./особенность": {
      "узел": "./feature-node.js ",
      "по умолчанию": "./feature.js "
    }
  }
}
Определяет пакет, в котором require("pkg/функция") и импорт "pkg/функция" могут обеспечивать 
различные реализации между Node.js и другие среды JS.

При использовании ветвей среды всегда включайте условие "по умолчанию", где это возможно. 
Предоставление условия "по умолчанию" гарантирует, что любые неизвестные среды JS смогут 
использовать эту универсальную реализацию, что помогает избежать необходимости этих сред 
JS притворяться существующими средами для поддержки пакетов с условным экспортом. 
По этой причине использование ветвей условий "узел" и "по умолчанию" обычно предпочтительнее, 
чем использование ветвей условий "узел" и "браузер".

Вложенные условия#
В дополнение к прямым сопоставлениям, Node.js также поддерживает вложенные объекты условий.

Например, чтобы определить пакет, который имеет только точки входа в двухрежимном режиме 
для использования в Node.js но не браузер:

{
  "главное": "./main.js ",
"экспорт": {
    "узел": {
      "импорт": "./узел функций.mjs",
"требуется": "./узел функций.cjs"
    },
"по умолчанию": "./feature.mjs",
}
}
Условия продолжают согласовываться по порядку, как и в случае с плоскими условиями. 
Если вложенное условие не имеет никакого сопоставления, оно продолжит проверку остальных 
условий родительского условия. Таким образом, вложенные условия ведут себя аналогично 
вложенным операторам JavaScript if.

Разрешение пользовательских условий#
Добавлено в: v14.9.0, v12.19.0
При беге Node.js , пользовательские условия пользователя могут быть добавлены с помощью 
флага --условия:

узел --условия=развитие main.js
который затем разрешит условие "разработка" при импорте и экспорте пакетов, одновременно 
разрешая существующие условия "узел", "узлы-дополнения", "по умолчанию", "импорт" и "требуется", 
если это необходимо.

С помощью флагов повтора можно задать любое количество пользовательских условий.

Определения условий#
Условия "импорт" , "требуется", "узел", "узлы-дополнения" и "по умолчанию" определены и 
реализованы в Node.js ядро, как указано выше.

Условие "узлы-дополнения" может быть использовано для обеспечения точки входа, которая 
использует собственные дополнения C++. Однако это условие можно отключить с помощью флага 
--no-addons. При использовании "надстроек узлов" рекомендуется рассматривать "по умолчанию" 
как усовершенствование, обеспечивающее более универсальную точку входа, например, 
использование WebAssembly вместо встроенного дополнения.

Другие строки условий неизвестны Node.js и, следовательно, игнорируется по умолчанию. 
Среды выполнения или инструменты, отличные от Node.js можете использовать их по своему усмотрению.

Эти пользовательские условия могут быть включены в Node.js с помощью флага --условия.

Следующие определения условий в настоящее время одобрены Node.js:

"браузер" - любая среда, которая реализует стандартное подмножество глобальных API-интерфейсов 
браузера, доступных с помощью JavaScript в веб-браузерах, включая API DOM.
"разработка" - может использоваться для определения точки входа в среду только для разработки. 
Всегда должно быть взаимоисключающим с "производством".
"производство" - может использоваться для определения точки входа в производственную среду. 
Всегда должно быть взаимоисключающим с "развитием".
Вышеуказанные условия пользователя могут быть включены в Node.js с помощью флага --условия.

Могут использоваться специфические для платформы условия, такие как "deno", "electron" или 
"react-native", но, хотя у этих платформ по-прежнему нет намерений по внедрению или интеграции, 
вышеуказанное явно не одобрено Node.js .

Определения новых условий могут быть добавлены в этот список путем создания запроса на 
извлечение в Node.js документация для этого раздела. Требования к перечислению здесь 
определения нового условия заключаются в том, что:

Определение должно быть четким и недвусмысленным для всех исполнителей.
Пример использования, объясняющий, почему это условие необходимо, должен быть четко обоснован.
Должно существовать достаточное количество существующих реализаций.
Имя условия не должно конфликтовать с другим определением условия или широко используемым условием.
Перечисление определения состояния должно обеспечить экосистеме преимущества в плане координации, 
которые в противном случае были бы невозможны. Например, это не обязательно относится к 
условиям конкретной компании или конкретного приложения.
Вышеприведенные определения могут быть перенесены в специальный реестр условий в надлежащее время.

Самостоятельная ссылка на пакет с использованием его имени#
История
Внутри пакета на значения, определенные в поле package.json "экспорт" пакета, можно 
ссылаться через имя пакета. Например, предполагая, что файл package.json является:

// пакет.json
{
  "имя": "a-пакет",
"экспорт": {
    ".": "./main.mjs",
"./foo": "./foo.js "
  }
}
Затем любой модуль в этом пакете может ссылаться на экспорт в самом пакете:

// ./a-module.mjs
импортирует { что-то } из "a-пакета"; // Импортирует "что-то" из ./main.mjs.
Самостоятельная ссылка доступна только в том случае, если package.json имеет "экспорт" 
и позволит импортировать только то, что позволяет этот "экспорт" (в package.json). 
Таким образом, приведенный ниже код, учитывая предыдущий пакет, приведет к ошибке во время выполнения:

// ./другой-модуль.mjs

// Импортирует "другой" из ./m.mjs. Терпит неудачу, потому что
// поле "экспорт" "package.json" "package.json"
// не предоставляет экспорт с именем "./m.mjs".
импортировать { другое } из 'a-package/m.mjs';
Самостоятельная ссылка также доступна при использовании require, как в модуле ES, так и 
в модуле CommonJS. Например, этот код также будет работать:

// ./a-module.js
const { что-то } = требуется('a-пакет/foo'); // Загружается из ./foo.js .
Наконец, самоссылка также работает с пакетами с ограниченной областью действия. Например, 
этот код также будет работать:

// пакет.json
{
  "имя": "@мой/пакет",
"экспорт": "./index.js "
}
// ./index.js
модуль.экспорт = 42;
// ./other.js
консоль.журнал(требуется('@мой/пакет'));
$ узел other.js
42
Двойные пакеты модулей CommonJS/ES#
До внедрения поддержки модулей ES в Node.js , для авторов пакетов было обычным делом 
включать в свой пакет источники JavaScript как CommonJS, так и ES-модулей, при этом package.json 
"main" указывал точку входа CommonJS, а package.json "модуль" указывал точку входа ES-модуля. 
Это позволило Node.js для запуска точки входа CommonJS, в то время как инструменты сборки, 
такие как пакеты, использовали точку входа модуля ES, поскольку Node.js проигнорировал 
(и все еще игнорирует) поле "модуль" верхнего уровня.

Node.js теперь можно запускать точки входа модуля ES, и пакет может содержать как точки входа 
модуля CommonJS, так и ES (либо с помощью отдельных спецификаторов, таких как "pkg" и 
"pkg /es-модуль", либо оба в одном спецификаторе с помощью условного экспорта). 
В отличие от сценария, в котором "модуль" используется только сборщиками, или файлы модулей 
ES переносятся в CommonJS на лету перед оценкой с помощью Node.js , файлы, на которые 
ссылается точка входа модуля ES, оцениваются как модули ES.

Опасность двойной упаковки#
Когда приложение использует пакет, который предоставляет как исходные коды модулей CommonJS, 
так и ES, существует риск возникновения определенных ошибок, если загружаются обе версии пакета. 
Этот потенциал связан с тем фактом, что pkgInstance, созданный с помощью const 
pkgInstance = require('pkg'), не совпадает с pkgInstance, созданным путем импорта pkgInstance 
из 'pkg' (или альтернативного основного пути, такого как 'pkg/модуль'). 
Это “опасность двойного пакета”, когда две версии одного и того же пакета могут быть загружены 
в одной и той же среде выполнения. Хотя маловероятно, что приложение или пакет намеренно 
загрузят обе версии напрямую, приложение обычно загружает одну версию, в то время как 
зависимость приложения загружает другую версию. Эта опасность может возникнуть из-за Node.js 
поддерживает смешивание модулей CommonJS и ES и может привести к неожиданному поведению.

Если основной экспорт пакета является конструктором, сравнение экземпляров, созданных 
двумя версиями, возвращает false, а если экспорт является объектом, свойства, добавленные 
в один (например, pkgInstance.foo = 3), отсутствуют в другом. Это отличается от того, 
как операторы импорта и требования работают в средах модулей all-CommonJS или all-ES 
соответственно, и поэтому вызывает удивление у пользователей. Это также отличается от поведения, 
знакомого пользователям при использовании транспиляции с помощью таких инструментов, 
как Babel или esm.

Написание двойных пакетов, избегая или сводя к минимуму опасности#
Во-первых, опасность, описанная в предыдущем разделе, возникает, когда пакет содержит 
как источники модулей CommonJS, так и ES, и оба источника предоставляются для использования в 
Node.js , либо через отдельные основные точки входа, либо по экспортированным путям. 
Вместо этого может быть написан пакет, в котором любая версия Node.js получает только источники 
CommonJS, и любые отдельные источники модулей ES, которые могут содержаться в пакете, 
предназначены только для других сред, таких как браузеры. Такой пакет можно было бы использовать 
в любой версии Node.js , так как импорт может ссылаться на файлы CommonJS; но это не дало 
бы никаких преимуществ использования синтаксиса модуля ES.

Пакет также может переключиться с синтаксиса модуля CommonJS на ES в случае критического 
изменения версии. Недостатком этого является то, что новейшая версия пакета будет использоваться 
только в версиях ES, поддерживающих модули Node.js .

У каждого шаблона есть компромиссы, но есть два широких подхода, которые удовлетворяют 
следующим условиям:

Пакет можно использовать как через запрос, так и через импорт.
Пакет можно использовать в обоих текущих Node.js и более старые версии Node.js в которых 
отсутствует поддержка модулей ES.
Основная точка входа в пакет, например 'pkg', может использоваться как require для разрешения 
в файл CommonJS, так и путем импорта для разрешения в файл модуля ES. (И аналогично для 
экспортированных путей, например 'pkg/feature'.)
Пакет обеспечивает именованный экспорт, например, импорт { имя } из 'pkg', а не импорт 
pkg из 'pkg'; pkg.name .
Пакет потенциально может быть использован в других средах модулей ES, таких как браузеры.
Опасности, описанные в предыдущем разделе, можно избежать или свести к минимуму.
Подход №1: Используйте оболочку модуля ES#
Запишите пакет в CommonJS или перенесите исходные тексты модулей ES в CommonJS и создайте 
файл-оболочку модуля ES, который определяет именованный экспорт. При использовании 
условного экспорта для импорта используется оболочка модуля ES, а для require - точка входа CommonJS.

// ./node_modules/pkg/пакет.json
{
  "тип": "модуль",
"основной": "./index.cjs",
"экспорт": {
    "импорт": "./оболочка.mjs",
"требуется": "./индекс.cjs"
  }
}
В предыдущем примере используются явные расширения .mjs и .cjs. Если ваши файлы используют 
расширение .js, "тип": "модуль" приведет к тому, что такие файлы будут рассматриваться 
как модули ES, точно так же, как "тип": "commonjs" приведет к тому, что они будут 
рассматриваться как CommonJS. См. раздел Включение.

// ./node_modules/pkg/индекс.cjs
exports.name = 'значение';
// ./node_modules/pkg/wrapper.mjs
импортирует cjsModule из './index.cjs';
имя константы экспорта = cjsModule.name;
В этом примере имя из import { name } из 'pkg' является тем же самым одноэлементным, 
что и имя из const { name } = require('pkg'). Поэтому === возвращает true при сравнении 
двух имен, и опасность расхождения спецификаторов исключается.

Если модуль представляет собой не просто список именованных экспортов, а содержит 
уникальную функцию или экспорт объектов, например module.exports = функция () { ... }, 
или если требуется поддержка в оболочке для импорта pkg из шаблона "pkg", 
то вместо этого оболочка будет написана для экспорта по умолчанию, необязательно, 
вместе с любым именованным экспортом, а также:

импортировать cjsModule из './index.cjs';
имя константы экспорта = cjsModule.name;
экспортировать модуль cjsModule по умолчанию;
Этот подход подходит для любого из следующих вариантов использования:

В настоящее время пакет написан на CommonJS, и автор предпочел бы не преобразовывать 
его в синтаксис модуля ES, но хотел бы предоставить именованный экспорт для потребителей модуля ES.
В пакете есть другие пакеты, которые зависят от него, и конечный пользователь может 
установить как этот пакет, так и эти другие пакеты. Например, пакет утилит используется 
непосредственно в приложении, а пакет утилит плюс добавляет в утилиты еще несколько функций. 
Поскольку оболочка экспортирует базовые файлы CommonJS, не имеет значения, написан ли 
utilities-plus в синтаксисе модуля CommonJS или ES; он будет работать в любом случае.
Пакет хранит внутреннее состояние, и автор пакета предпочел бы не проводить рефакторинг пакета, 
чтобы изолировать управление его состоянием. Смотрите следующий раздел.
Вариантом этого подхода, не требующего условного экспорта для потребителей, может быть 
добавление экспорта, например "./модуль", чтобы указать на версию пакета с синтаксисом 
модуля all-ES. Это может быть использовано с помощью импорта "pkg /модуль" пользователями, 
которые уверены, что версия CommonJS не будет загружена нигде в приложении, например, 
с помощью зависимостей; или если версия CommonJS может быть загружена, но не влияет 
на версию модуля ES (например, потому что пакет не имеет состояния):

// ./node_modules/pkg/пакет.json
{
  "тип": "модуль",
"основной": "./index.cjs",
"экспорт": {
    ".": "./индекс.cjs",
    "./модуль": "./оболочка.mjs"
  }
}
Подход №2: Изолированное состояние#
Файл package.json может напрямую определять отдельные точки входа модулей CommonJS и ES:

// ./node_modules/pkg/пакет.json
{
  "тип": "модуль",
"основной": "./index.cjs",
"экспорт": {
    "импорт": "./index.mjs",
"требуется": "./index.cjs"
  }
}
Это можно сделать, если обе версии модулей CommonJS и ES пакета эквивалентны, например, 
потому, что одна является транспилированным выводом другой; и управление состоянием пакета 
тщательно изолировано (или пакет не имеет состояния).

Причина, по которой это состояние является проблемой, заключается в том, что в приложении 
могут использоваться как версии модулей CommonJS, так и ES; например, код приложения 
пользователя может импортировать версию модуля ES, в то время как для зависимости требуется 
версия CommonJS. Если бы это произошло, в память были бы загружены две копии пакета и, 
следовательно, присутствовали бы два отдельных состояния. Это, скорее всего, приведет 
к трудным для устранения ошибкам.

Помимо написания пакета без состояния (например, если бы математика JavaScript была пакетом, 
она была бы без состояния, поскольку все ее методы статичны), существует несколько способов 
изолировать состояние, чтобы оно было разделено между потенциально загруженными экземплярами 
модулей CommonJS и ES пакета.:

Если возможно, содержите все состояния внутри созданного объекта. Дата JavaScript, например, 
должна быть создана, чтобы содержать состояние; если бы это был пакет, он использовался 
бы следующим образом:

импортировать дату из 'даты';
const someDate = новая дата();
// someDate содержит состояние; Дата не содержит
Ключевое слово new не требуется; функция пакета может возвращать новый объект или изменять 
переданный объект, чтобы сохранить состояние внешним по отношению к пакету.

Изолируйте состояние в одном или нескольких файлах CommonJS, которые являются общими для 
версий модулей CommonJS и ES пакета. Например, если точками входа модулей CommonJS и 
ES являются index.cjs и index.mjs соответственно:

// ./node_modules/pkg/index.
cjs постоянное состояние = требуется('./состояние.cjs');
модуль.экспорт.состояние = состояние;
// ./node_modules/pkg/index.mjs
импортирует состояние из "./state.cjs";
экспорт {
  состояние
};
Даже если pkg используется как через требование, так и через импорт в приложении (например, 
через импорт в коде приложения и через требование зависимостью), каждая ссылка на pkg будет 
содержать одно и то же состояние; и изменение этого состояния из любой модульной системы будет 
применяться к обоим.

Любые плагины, которые подключаются к синглетону пакета, должны быть отдельно подключены как к 
синглетонам модулей CommonJS, так и ES.

Этот подход подходит для любого из следующих вариантов использования:

В настоящее время пакет написан в синтаксисе модуля ES, и автор пакета хочет, чтобы эта версия 
использовалась везде, где поддерживается такой синтаксис.
Пакет не имеет состояния или его состояние может быть изолировано без особых трудностей.
В пакете вряд ли будут другие общедоступные пакеты, которые зависят от него, или, если это так, 
пакет не имеет состояния или имеет состояние, которое не нужно разделять между зависимостями или 
с приложением в целом.
Даже в изолированном состоянии по-прежнему существует стоимость возможного дополнительного 
выполнения кода между версиями модулей CommonJS и ES пакета.

Как и в случае с предыдущим подходом, вариантом этого подхода, не требующим условного экспорта 
для потребителей, может быть добавление экспорта, например "./модуль", чтобы указать на версию 
пакета с синтаксисом модуля all-ES:

// ./node_modules/pkg/пакет.json
{
  "тип": "модуль",
"основной": "./index.cjs",
"экспорт": {
    ".": "./index.cjs",
"./модуль": "./index.mjs"
  }
}
Node.js определения полей package.json#
В этом разделе описываются поля, используемые Node.js время выполнения. Другие инструменты 
(такие как npm) используют дополнительные поля, которые игнорируются Node.js и здесь это не 
задокументировано.

Следующие поля в файлах package.json используются в Node.js:

"имя" - актуально при использовании именованного импорта в пакете. Также используется менеджерами 
пакетов в качестве имени пакета.
"основной" - модуль по умолчанию при загрузке пакета, если экспорт не указан, и в версиях Node.js 
до введения экспорта.
"PackageManager" - менеджер пакетов, рекомендуемый при внесении вклада в пакет. Усиленный 
прокладками Corepack.
"тип" - тип пакета, определяющий, следует ли загружать файлы .js в качестве модулей CommonJS 
или ES.
"экспорт" - экспорт посылок и условный экспорт. Если присутствует, ограничивает, какие 
подмодули могут быть загружены из пакета.
"импорт" - Импорт пакета для использования модулями внутри самого пакета.

"имя"#
История
Тип: <строка>
{
  "имя": "имя пакета"
}
Поле "имя" определяет имя вашего пакета. Для публикации в реестре npm требуется имя, 
удовлетворяющее определенным требованиям.

Поле "имя" можно использовать в дополнение к полю "экспорт" для самостоятельной ссылки 
на пакет с использованием его имени.

"главный"#
Добавлено в: v0.4.0
Тип: <строка>
{
  "главное": "./main.js "
}
Поле "основной" определяет сценарий, который используется при загрузке каталога пакетов 
с помощью require(). Его ценность - это путь.

требовать('./путь/к/каталогу'); // Это разрешает ./path/to/directory/main.js .
Если в пакете есть поле "экспорт", оно будет иметь приоритет над полем "основной" при 
импорте пакета по имени.

"Менеджер пакетов"

{
"PackageManager": "<имя менеджера пакетов>@<версия>"
}
Поле "PackageManager" определяет, какой менеджер пакетов предполагается использовать при 
работе над текущим проектом. Он может быть установлен на любой из поддерживаемых менеджеров 
пакетов и гарантирует, что ваши команды будут использовать одни и те же версии менеджера 
пакетов без необходимости устанавливать что-либо еще, кроме Node.js .

В настоящее время это поле является экспериментальным и должно быть включено; 
проверьте страницу Corepack для получения подробной информации о процедуре.

"тип"#
История
Тип: <строка>
Поле "тип" определяет формат модуля, который Node.js используется для всех файлов .js, 
которые имеют этот файл package.json в качестве ближайшего родителя.

Файлы, заканчивающиеся на .js, загружаются как модули ES, если ближайший родительский 
файл пакета.json содержит поле верхнего уровня "тип" со значением "модуль".

Ближайший родительский файл package.json определяется как первый файл package.json, 
найденный при поиске в текущей папке, родительской папке этой папки и т. Д., 
Пока не будет достигнута папка node_modules или корневой том.

// пакет.json
{
  "тип": "модуль"
}
# В той же папке, что и предыдущий пакет.json
узел my-app.js # Работает как модуль ES
Если в ближайшем родительском пакете.json отсутствует поле "тип" или содержит "тип": "commonjs", 
файлы .js рассматриваются как CommonJS. Если достигнут корневой каталог тома и не найден 
файл package.json, файлы .js обрабатываются как CommonJS.

инструкции импорта файлов .js обрабатываются как модули ES, если ближайший родительский 
пакет.json содержит "тип": "модуль".

// my-app.js , часть того же примера, что и выше
"импорт"./startup.js '; // Загружается как модуль ES из-за package.json
Независимо от значения поля "тип", файлы .mjs всегда рассматриваются как модули ES, а 
файлы .cjs всегда рассматриваются как CommonJS.

"экспорт"#
История
Тип: <Объект> | <строка> | <строка[]>
{
  "экспорт": "./index.js "
}
Поле "экспорт" позволяет определять точки входа пакета при импорте по имени, загруженному 
либо с помощью поиска node_modules, либо с помощью ссылки на собственное имя. 
Он поддерживается в Node.js 12+ в качестве альтернативы "основному", который может 
поддерживать определение экспорта подпутей и условного экспорта при инкапсуляции 
внутренних неэкспортированных модулей.

Условный экспорт также можно использовать в разделе "экспорт" для определения различных 
точек входа пакета для каждой среды, в том числе для указания того, ссылается ли пакет 
через запрос или через импорт.

Все пути, определенные в разделе "экспорт", должны быть относительными URL-адресами файлов, 
начинающимися с ./.

"импорт"#
Добавлено в: v14.6.0, v12.19.0
Тип: <Объект>
// пакет.json
{
  "импорт": {
    "#dep": {
      "узел": "деп-узел-родной",
"по умолчанию": "./dep-polyfill.js "
    }
},
"зависимости": {
    "dep-родной узел": "^1.0.0"
  }
}
Записи в поле импорт должны быть строками, начинающимися с #.

Карты импорта позволяют сопоставлять с внешними пакетами.

Это поле определяет импорт подпутей для текущего пакета.