Цикл событий - один из наиболее важных аспектов, которые необходимо понять Node.js .

Почему это так важно? Потому что это объясняет, как Node.js может быть асинхронным 
и иметь неблокирующий ввод-вывод, и поэтому это в основном объясняет 
"приложение-убийца" Node.js , то, что сделало его таким успешным.

В Node.js Код JavaScript выполняется в одном потоке. Одновременно происходит только одна вещь.

Это ограничение на самом деле очень полезно, так как оно значительно упрощает программирование, 
не беспокоясь о проблемах параллелизма.

Вам просто нужно обратить внимание на то, как вы пишете свой код, и избегать всего, 
что может блокировать поток, например синхронных сетевых вызовов или бесконечных циклов.

Как правило, в большинстве браузеров существует цикл событий для каждой вкладки браузера, 
чтобы изолировать каждый процесс и избежать веб-страницы с бесконечными циклами или 
интенсивной обработкой, которая блокирует весь ваш браузер.

Среда управляет несколькими параллельными циклами событий, например, для обработки вызовов API. 
Веб-работники также работают в своем собственном цикле событий.

В основном вам нужно беспокоиться о том, что ваш код будет выполняться в одном цикле событий, 
и писать код с учетом этого, чтобы избежать его блокировки.

Блокировка цикла событий
Любой код JavaScript, который занимает слишком много времени для возврата управления 
в цикл событий, заблокирует выполнение любого кода JavaScript на странице, 
даже заблокирует поток пользовательского интерфейса, и пользователь не сможет щелкнуть, 
прокрутить страницу и так далее.

Почти все примитивы ввода-вывода в JavaScript неблокирующие. Сетевые запросы, операции 
с файловой системой и так далее. Блокирование является исключением, и именно поэтому 
JavaScript в значительной степени основан на обратных вызовах, а в последнее время - 
на обещаниях и асинхронности / ожидании.

Стек вызовов
Стек вызовов представляет собой стек LIFO (Последний вход, Первый выход).

Цикл событий непрерывно проверяет стек вызовов, чтобы определить, есть ли какая-либо функция, 
которую необходимо запустить.

При этом он добавляет любой найденный вызов функции в стек вызовов и выполняет каждый по порядку.

Вы знаете трассировку стека ошибок, с которой вы, возможно, знакомы, в отладчике или 
в консоли браузера? Браузер просматривает имена функций в стеке вызовов, чтобы сообщить вам, 
какая функция инициирует текущий вызов: